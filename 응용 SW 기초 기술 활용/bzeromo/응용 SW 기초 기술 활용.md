***
# ⚡ 응용 SW 기초 기술 활용
***

> [학습에 사용한 교재 (2025 시나공 퀵이지 정보처리기사 실기 단기완성)](https://www.aladin.co.kr/m/mproduct.aspx?ItemId=341611409&srsltid=AfmBOooInt5TDiPU-hLfwuLkPsx35KRQ1nN_mrbu2ujcfUtYH5JivYZl)

## 1. **`운영체제 기초`**
   
📌 **운영체제의 역할** <br>
   
- 프로세스 관리: 실행 중인 프로그램을 프로세스라 하며, 프로세스 상태 전이, 스케줄링 등이 해당됨.


- 기억장치 관리: 메모리 할당/회수 (페이징, 세그먼테이션)


- 파일 관리: 파일 시스템 지원 (계층적 구조, 접근 제어 등)


- 입출력 관리: I/O 디바이스 제어

📌 **대표 운영체제** </br>

| 운영체제           | 특징                          |
| -------------- | --------------------------- |
| **UNIX/Linux** | 멀티유저/멀티태스킹, CLI 중심, 보안 강함   |
| **Windows**    | GUI 중심, 다양한 SW와 호환, 사용자 친화적 |

---

## 2. **`운영체제 핵심`**

| 주제           | 설명                                                                |
| ------------ | ----------------------------------------------------------------- |
| **프로세스/스레드** | PCB(Process Control Block), Context Switching, 멀티태스킹, 스레드 간 자원 공유 |
| **스케줄링**     | FCFS, SJF, RR, 다단계 큐                                              |
| **메모리 관리**   | 페이징, 세그먼테이션, 가상메모리, 페이지 교체 알고리즘 (FIFO, LRU)                       |
| **디스크 스케줄링** | FCFS, SSTF, SCAN, C-SCAN                                          |
| **리눅스 명령어**  | `ps`, `top`, `ls`, `chmod`, `grep`, `cat`, `vi` 등 자주 출제           |
| **리눅스 구조**   | 커널, 쉘, 파일시스템 구조 (/, /home, /etc, /var 등)                          |

---

### ✅ [1] 프로세스 / 스레드

#### 🔹 **1-1. 프로세스(Process)**

📌 정의 <br>
- 실행 중인 프로그램을 의미


- 운영체제는 정적인 프로그램 코드를 메모리에 로드하여 실행 단위인 프로세스로 만든다.

📌 주요 구성 요소

| 요소                        | 설명                                |
| ------------------------- | --------------------------------- |
| **코드 영역 (Text Segment)**  | 실행할 프로그램 코드                       |
| **데이터 영역 (Data Segment)** | 전역 변수, 정적 변수                      |
| **힙 영역 (Heap)**           | 동적 메모리 할당 공간                      |
| **스택 영역 (Stack)**         | 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 주소 등 |

---

#### 🔹 1-2. PCB (Process Control Block)

📌 정의 <br>

- 운영체제가 프로세스를 관리하기 위해 사용하는 자료구조


- 프로세스의 상태, 프로그램 카운터, 메모리 정보 등을 저장

📌 주요 항목

| 항목                  | 설명                        |
| ------------------- | ------------------------- |
| **PID**             | 프로세스 고유 식별자               |
| **상태**              | Ready, Running, Waiting 등 |
| **Program Counter** | 다음에 실행할 명령어 주소            |
| **레지스터 정보**         | CPU 레지스터 값들 저장            |
| **스케줄링 정보**         | 우선순위, 큐 정보                |
| **메모리 정보**          | 코드/데이터/스택/힙 위치            |
| **입출력 정보**          | 열린 파일, 입출력 장치 등           |

---

#### 🔹 1-3. 프로세스 상태 전이

```
[New] → [Ready] → [Running] → [Waiting] → [Terminated]
                  ↑            ↓
                [→ Ready]   [→ Ready]
```

| 상태             | 설명          |
| -------------- | ----------- |
| **New**        | 생성 중인 상태    |
| **Ready**      | CPU 할당을 기다림 |
| **Running**    | CPU에서 실행 중  |
| **Waiting**    | I/O 작업 대기   |
| **Terminated** | 실행 완료       |

---

#### 🔹 1-4. Context Switching

📌 정의

- 실행 중인 프로세스를 중단하고, 다른 프로세스로 전환할 때 발생


- CPU는 이전 프로세스의 문맥(Context) 을 저장하고, 새로운 프로세스의 문맥을 복원

📌 문맥(Context)의 구성

- 프로그램 카운터(PC)


- 레지스터 값


- 스택 포인터


- 프로세스 상태 정보 (PCB)

📌 비용

오버헤드가 존재 → 자주 발생하면 전체 시스템 성능 저하

---

#### 🔹 1-5. 스레드(Thread)

📌 정의

- 프로세스 내에서 실제 작업을 수행하는 실행 단위


- 하나의 프로세스는 여러 개의 스레드를 가질 수 있음 (멀티스레딩)

📌 특징


- 경량 프로세스라고 불림


- 같은 프로세스 내의 스레드들은 코드, 데이터, 힙을 공유


- 스택은 각각 별도로 유지

---

#### 🔹 1-6. 프로세스 vs 스레드

| 항목    | 프로세스                       | 스레드                         |
| ----- | -------------------------- | --------------------------- |
| 정의    | 실행 중인 프로그램                 | 프로세스 내 실행 흐름 단위             |
| 메모리   | 독립된 메모리 공간                 | 코드/데이터/힙 공유, 스택만 분리         |
| 생성 비용 | 큼 (Context Switching 비용 큼) | 작음                          |
| 통신 방식 | IPC(파이프, 메시지 큐 등)          | 공유 메모리 사용 가능                |
| 안정성   | 하나 종료되어도 다른 프로세스에 영향 없음    | 하나의 스레드가 오류 시 전체 프로세스 종료 가능 |

---

#### ✅ 요약 정리

`프로세스`: 실행 단위, 독립된 자원 소유

`스레드`: 프로세스 내부 실행 흐름, 자원 공유

`PCB`: 프로세스를 관리하기 위한 핵심 정보

`Context Switching`: CPU가 문맥을 저장/복원하며 프로세스 전환

`멀티스레딩`: 효율적인 자원 사용과 빠른 응답 가능하지만, 동기화 문제 주의

---

### ✅ [2] 스케줄링(Scheduling)

#### 🔹 2-1. 스케줄링이란?

📌 정의

- CPU가 여러 프로세스를 효율적으로 처리하기 위해 어떤 프로세스를 다음에 실행할지 결정하는 작업


- CPU는 항상 1개의 프로세스만 실행 가능 → 멀티태스킹 환경에서는 스케줄링이 필수

📌 목적

- 응답시간 최소화


- CPU 이용률 극대화


- 공정한 자원 분배


- Throughput(처리량) 증가

---

#### 🔹 2-2. 스케줄링 기준 용어

| 용어                          | 설명                        |
| --------------------------- | ------------------------- |
| **도착시간 (Arrival Time)**     | 프로세스가 ready queue에 들어온 시점 |
| **서비스 시간 (Burst Time)**     | 프로세스가 CPU에서 실제로 필요한 시간    |
| **대기 시간 (Waiting Time)**    | 준비 큐에서 기다린 총 시간           |
| **반환 시간 (Turnaround Time)** | 종료 시점 - 도착 시점 (총 소요 시간)   |
| **응답 시간 (Response Time)**   | 최초 실행 시간 - 도착 시간          |

---

#### 🔹 2-3. 스케줄링 방식 분류

| 분류                        | 설명                     | 예시             |
| ------------------------- | ---------------------- | -------------- |
| **비선점형 (Non-preemptive)** | CPU를 할당하면 끝날 때까지 양보 안함 | FCFS, SJF      |
| **선점형 (Preemptive)**      | 더 중요한 작업이 오면 양보        | RR, SRTF, 우선순위 |

---

#### 🔹 2-4. 주요 스케줄링 알고리즘

✅ **(1) FCFS – First Come First Served**

가장 먼저 도착한 프로세스부터 처리 (선입선출 큐)

📌 특징

- 비선점형


- 구현이 단순하나, 대기 시간 편차가 큼

📌 단점

- Convoy Effect (느린 작업이 빠른 작업을 막음)

✅ **(2) SJF – Shortest Job First**

- 수행 시간이 가장 짧은 프로세스부터 실행

📌 특징

- 비선점형 or 선점형(SRTF) 으로 나뉨


- 평균 대기시간 최소화 (이론적으로 가장 효율적)

📌 단점

- 실행 시간을 미리 알아야 함


- 기아(Starvation) 문제 발생 가능 (긴 작업은 계속 뒤로 밀림)

✅ **(3) RR – Round Robin**

- 프로세스에 시간 할당량(Time Quantum) 을 주고, 일정 시간만 실행


- 시간이 지나면 다음 프로세스로 교체

📌 특징

- 선점형


- 응답시간이 빠름 → 대화형 시스템(Interactive)에 적합

📌 단점

- Quantum이 너무 크면 FCFS에 가까워지고, 작으면 Context Switching 비용이 큼

✅ **(4) Priority Scheduling – 우선순위 기반**


- 각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스 먼저 실행

📌 특징

- 선점형 또는 비선점형 둘 다 가능

📌 단점

- 기아 현상 발생 가능

- → 해결: Aging 기법 (대기 시간이 길수록 우선순위 상승)

✅ **(5) Multilevel Queue Scheduling – 다단계 큐**

- 프로세스를 성격에 따라 여러 큐로 나눠 각각 다른 스케줄링 방식 적용

📌 예시

| 큐       | 내용        | 알고리즘 |
| ------- | --------- | ---- |
| 시스템 큐   | 운영체제 작업   | RR   |
| 인터랙티브 큐 | 사용자 입력 대기 | RR   |
| 배치 작업 큐 | 계산 위주     | FCFS |

---

#### 🔍 예시

프로세스 P1~P3가 다음과 같이 도착한다고 가정

| 프로세스 | 도착 시간 | 실행 시간 |
| ---- | ----- | ----- |
| P1   | 0     | 8     |
| P2   | 1     | 4     |
| P3   | 2     | 2     |

`FCFS`: P1 → P2 → P3

`SJF`: P3 → P2 → P1

`RR`(Quantum = 2): P1(2) → P2(2) → P3(2) → P1(2) → P2(2) → P1(4)

---

### ✅ [3] 메모리 관리

#### 🔹 3-1. 메모리 관리란?
📌 정의

- CPU와 프로그램 간의 데이터 교환을 위해 메모리를 효율적으로 관리하는 기법


- 운영체제는 한정된 주기억장치를 여러 프로세스가 공정하게, 빠르게, 효율적으로 사용하도록 제어

---

#### 🔹 3-2. 메모리 관리 방식의 발전 단계

| 방식                   | 설명                         |
| -------------------- | -------------------------- |
| 고정 분할                | 물리적 메모리를 고정 크기로 나눔 (낭비 심함) |
| 가변 분할                | 크기 맞게 동적으로 분할 (조각 문제 발생)   |
| 페이징(Paging)          | 고정 크기 페이지로 나눠 관리           |
| 세그먼테이션(Segmentation) | 논리적 단위(함수/배열 등)로 나눠 관리     |
| 가상 메모리               | 실제 메모리보다 큰 주소 공간 제공        |

---

#### 🔹 3-3. 페이징(Paging)
📌 개념

- 고정 크기의 블록 단위로 논리 주소를 물리 주소로 매핑하는 방식

| 용어             | 설명                          |
| -------------- | --------------------------- |
| **페이지(Page)**  | 프로세스의 논리 주소 공간 단위           |
| **프레임(Frame)** | 물리 메모리의 동일 크기 블록            |
| **페이지 테이블**    | 페이지 번호 → 프레임 번호 매핑 정보 저장 구조 |

📌 특징

- 외부 단편화(External Fragmentation) 해결


- 내부 단편화(Internal Fragmentation)는 발생 가능


- 주소 변환 시 MMU(Memory Management Unit) 사용

---

#### 🔹 3-4. 세그먼테이션(Segmentation)

📌 개념

- 논리적 의미 단위로 주소 공간을 분할 (ex. 코드, 데이터, 스택)

| 구성           | 설명                       |
| ------------ | ------------------------ |
| **세그먼트 번호**  | 논리 단위 구분                 |
| **오프셋**      | 세그먼트 내부의 위치              |
| **세그먼트 테이블** | 세그먼트 번호 → 시작주소, 길이 정보 저장 |

📌 특징


- 외부 단편화 발생 가능


- 내부 단편화는 없음


- 사용자 관점에서 더 직관적인 메모리 구조 표현 가능

---

#### 🔹 3-5. 가상 메모리(Virtual Memory)

📌 개념

- 보조기억장치(HDD/SSD)를 주기억장치처럼 사용하여, 실제보다 큰 메모리 공간 제공

| 구성요소                   | 설명                     |
| ---------------------- | ---------------------- |
| **스왑 공간(Swap Space)**  | HDD에 존재하는 메모리 보조 영역    |
| **페이지 폴트(Page Fault)** | 필요한 페이지가 메모리에 없는 경우 발생 |
| **Demand Paging**      | 실제 접근할 때만 페이지를 메모리에 로드 |

📌 장점

- 많은 프로그램을 동시에 실행 가능


- 물리 메모리 부족 문제 완화

📌 단점

- 디스크 접근이 많아지면 속도 느려짐 (Thrashing 현상)

---

#### 🔹 3-6. 페이지 교체 알고리즘 (Page Replacement)

📌 필요성

- 가상 메모리에서 메모리가 꽉 찼을 때, 어떤 페이지를 제거하고 새로운 페이지를 넣을지 결정

✅ **(1) FIFO – First-In First-Out**

- 가장 오래된 페이지부터 제거


- 구현 쉬우나 성능은 낮음 (Belady’s anomaly 발생)

✅ **(2) LRU – Least Recently Used**

- 가장 오랫동안 사용하지 않은 페이지 제거


- 과거 참조 시간 추적 필요 (스택 or 카운터 사용)

✅ **(3) Optimal – 최적 알고리즘**

- 앞으로 가장 오랫동안 사용하지 않을 페이지 제거


- 이상적이지만 실제 구현 불가 → 이론적 기준

✅ **(4) LFU – Least Frequently Used**

- 가장 적게 참조된 페이지 제거


- 참조 횟수를 누적해서 기록해야 함

---

🔍 **LRU 페이지 교체 예시**

페이지 프레임 3개, 참조 순서: 1 2 3 2 4 1 3 5

| 순서 | 프레임 상태  | Page Fault 발생? |
| -- | ------- | -------------- |
| 1  | 1 \_ \_ | ✅              |
| 2  | 1 2 \_  | ✅              |
| 3  | 1 2 3   | ✅              |
| 4  | 1 2 3   | ❌              |
| 5  | 2 3 4   | ✅ (1 제거)       |
| 6  | 3 4 1   | ✅ (2 제거)       |
| 7  | 3 4 1   | ❌              |
| 8  | 4 1 5   | ✅ (3 제거)       |

총 Page Fault: 6회

---

### ✅ [4] 디스크 스케줄링(Disk Scheduling)

#### 🔹 4-1. 디스크 스케줄링이란?

📌 정의

- 디스크 I/O 요청이 여러 개 들어올 경우, 헤드의 이동을 최소화하여 효율적으로 처리하는 방법을 결정하는 알고리즘

---

#### 🔹 4-2. 디스크 접근 시간 구성

| 항목                            | 설명                                 |
| ----------------------------- | ---------------------------------- |
| **탐색 시간(Seek Time)**          | 헤드가 원하는 트랙으로 이동하는 데 걸리는 시간         |
| **회전 지연(Rotational Latency)** | 디스크가 회전하여 원하는 섹터가 헤드 아래에 올 때까지의 시간 |
| **전송 시간(Transfer Time)**      | 실제 데이터를 읽고 쓰는 시간                   |

> 디스크 스케줄링은 주로 탐색 시간(Seek Time) 을 줄이기 위해 사용됨

---

#### 🔹 **4-3. 주요 디스크 스케줄링 알고리즘**

✅ **(1) FCFS – First Come First Served**

- 요청 순서대로 처리


- 구현 간단하지만 비효율적

📌 예시

- 요청 순서: 98, 183, 37, 122, 14, 124, 65, 67

- 초기 헤드: 53

→ 총 이동거리
= |53-98| + |98-183| + ... = 640


✅ **(2) SSTF – Shortest Seek Time First**

- 현재 헤드 위치에서 가장 가까운 요청부터 처리


- 이동 거리 감소 가능

📌 단점

- 기아(Starvation) 발생 가능 (먼 요청이 계속 밀림)

📌 예시

- 초기 헤드 53 → 가장 가까운 65 → 67 → 37 …
→ 총 이동거리 약 236 (FCFS보다 훨씬 효율적)

✅ **(3) SCAN – 전형적인 전기 엘리베이터 방식**

- 한 방향으로 이동하며 요청 처리


- 끝에 도달하면 방향 전환


📌 예시 (초기: 53 → 오른쪽 진행)

- 53 → 65 → 67 → 98 → 122 → 124 → 183 → (끝) → 역방향 시작

→ 탐색 거리를 균등하게 분산시키는 장점

✅ **(4) C-SCAN – Circular SCAN**

- SCAN과 유사


- 한 방향으로만 쭉 가고 → 끝에 도달하면 맨 앞으로 되돌아옴

📌 특징

- 응답 시간 편차가 적고 공정함


- 엘리베이터가 한 방향만 운행하는 구조


✅ **(5) LOOK / C-LOOK**

- SCAN의 변형 버전


- 디스크의 끝까지 가지 않고, 마지막 요청까지만 이동 후 방향 전환

→ 불필요한 이동 제거

---

#### 🔹 4-4. 알고리즘 비교 요약표

| 알고리즘       | 장점            | 단점           |
| ---------- | ------------- | ------------ |
| **FCFS**   | 구현 단순         | 긴 이동 거리, 비효율 |
| **SSTF**   | 이동 거리 최소화     | 기아 가능성       |
| **SCAN**   | 전체 요청 공정하게 처리 | 끝까지 이동해야 함   |
| **C-SCAN** | 응답 시간 고름      | 되돌아오는 비용     |
| **LOOK**   | 불필요한 이동 줄임    | 구현 복잡도 증가    |

---

### 🔍 실제 문제 예시

디스크 요청 순서: 82, 170, 43, 140, 24, 16, 190

초기 헤드: 50

| 알고리즘   | 총 이동 거리 (예시) |
| ------ | ------------ |
| FCFS   | 642          |
| SSTF   | 236          |
| SCAN   | 208          |
| C-SCAN | 322          |
| LOOK   | 200          |

---

### ✅ [5] Linux

📌 **리눅스 기초**

https://velog.io/@bzeromo/Linux-Ubuntu

📌 **리눅스 응용**

https://velog.io/@bzeromo/Linux

---

## 3. **`네트워크`**

### 🔹1.  **네트워크 7계층 (OSI 7 Layer)**

| 계층         | 주요 역할      | 프로토콜 예시         |
| ---------- | ---------- | --------------- |
| 7. 응용계층    | 사용자 인터페이스  | HTTP, FTP, SMTP |
| 6. 표현계층    | 데이터 형식 변환  | ASCII, JPEG     |
| 5. 세션계층    | 통신 세션 관리   | NetBIOS         |
| 4. 전송계층    | 신뢰성 있는 전송  | TCP, UDP        |
| 3. 네트워크계층  | 주소 지정, 라우팅 | IP              |
| 2. 데이터링크계층 | 오류검출, 프레임화 | MAC, Ethernet   |
| 1. 물리계층    | 전기적 신호 전송  | RS-232, USB     |

---

### 🔹2.  **TCP/IP 4계층 구조**

- 응용 계층: HTTP, FTP


- 전송 계층: TCP, UDP


- 인터넷 계층: IP, ICMP


- 네트워크 접근 계층: MAC, Ethernet

---

### 🔹 3. IP 주소 체계

`IPv4`: 32비트 주소 (ex: 192.168.0.1)

`IP 클래스`:

A: 0127, B: 128191, C: 192~223

`공인 IP`: 인터넷 상 식별 가능

`사설 IP`: 내부망용 (예: 192.168.x.x, 10.x.x.x)

`서브넷팅`: IP 주소를 네트워크/호스트로 나누는 방식

---

### 🔹 4. 주요 포트 번호

| 프로토콜  | 포트 번호 |
| ----- | ----- |
| HTTP  | 80    |
| HTTPS | 443   |
| FTP   | 21    |
| SSH   | 22    |
| DNS   | 53    |
| SMTP  | 25    |

---

### 🔹 5. 전송 방식 종류

| 방식     | 설명                     |
| ------ | ---------------------- |
| 유니캐스트  | 1:1 전송 (일반적인 통신)       |
| 멀티캐스트  | 1:다수 일부 그룹 대상 (스트리밍 등) |
| 브로드캐스트 | 전체 노드 대상 전송 (LAN에서 사용) |

---

### 🔹 6. DNS & DHCP

| 항목                                         | 설명                |
| ------------------------------------------ | ----------------- |
| DNS (Domain Name System)                   | 도메인 이름을 IP 주소로 변환 |
| DHCP (Dynamic Host Configuration Protocol) | IP 주소 자동 할당 프로토콜  |


---

### 🔹 7. MAC 주소 vs IP 주소

| 항목 | MAC 주소                                  | IP 주소              |
| -- | --------------------------------------- | ------------------ |
| 구분 | 물리 주소 (하드웨어 고정)                         | 논리 주소 (변경 가능)      |
| 위치 | 네트워크 인터페이스 카드                           | 운영체제에서 할당          |
| 형식 | 48비트, 16진수 (ex: AA\:BB\:CC\:DD\:EE\:FF) | IPv4 (192.168.0.1) |

---

### 🔹 8. 패킷 구조

`헤더(Header)`: 출발지/목적지 주소, 제어 정보

`페이로드(Payload)`: 실제 데이터
→ 전송 시 OSI 계층별로 캡슐화되어 전송됨

---

### 🔹 9. 네트워크 장비

| 장비                 | 기능                                  |
| ------------------ | ----------------------------------- |
| **허브(Hub)**        | 단순 신호 중계 (브로드캐스트)                   |
| **스위치(Switch)**    | MAC 기반 포트 연결, 충돌 최소화                |
| **라우터(Router)**    | IP 기반 네트워크 간 연결                     |
| **게이트웨이(Gateway)** | 서로 다른 네트워크 프로토콜 간 변환 (예: LAN ↔ WAN) |

---

## 4. 데이터베이스

### ✅ [1] 데이터 모델링 (Data Modeling)

#### 🔹 1-1. 데이터 모델링이란?

📌 정의

- 현실 세계의 정보를 데이터베이스에 표현하기 위한 설계 작업


- 즉, 사용자 요구사항을 분석 → 구조화 → DB에 반영하는 과정

📌 목적

- 데이터 중복 제거


- 데이터 간의 관계 명확히 정의


- 데이터 일관성과 무결성 유지


- 시스템 개발 초기 단계에서 오류 예방

---

#### 🔹 1-2. 모델링 단계

- 데이터 모델링은 개념 → 논리 → 물리의 3단계로 진행

✅ **(1) 개념적 모델링 (Conceptual Modeling)**

- 사용자의 요구사항을 추상화


- 업무 중심, 비기술자도 이해할 수 있는 모델


- ERD(Entity-Relationship Diagram) 를 사용하여 개체(Entity), 속성(Attribute), 관계(Relationship) 표현

📌 예시

- 개체: 고객(Customer), 주문(Order)

- 속성: 고객ID, 이름, 주문일자

- 관계: 고객은 여러 주문을 할 수 있다 (1:N 관계)

✅ **(2) 논리적 모델링 (Logical Modeling)**

- 개념 모델을 관계형 모델로 변환


- 정규화 수행


- 데이터 타입, 기본키/외래키 등 구조 설계 포함


- DBMS에 독립적

📌 산출물

- 테이블 목록

- 속성 목록

- 기본키/외래키 정의

- 관계 명세 (1:1, 1:N, N:M)

✅ **(3) 물리적 모델링 (Physical Modeling)**

- 논리 모델을 실제 DBMS 구조에 맞춰 구현


- DBMS에 종속적


- 인덱스, 파티션, 성능 고려 등 포함

📌 예시

- MySQL에서 VARCHAR(50)로 선언

- 인덱스 생성 (CREATE INDEX)

- 테이블스페이스, 스토리지 용량 고려

---

#### 🔹 1-3. ERD(Entity-Relationship Diagram)

📌 주요 구성 요소

| 구성 요소                | 기호              | 설명                       |
| -------------------- | --------------- | ------------------------ |
| **개체(Entity)**       | □ (사각형)         | DB로 구현될 주요 대상 (사람, 사물 등) |
| **속성(Attribute)**    | ○ (타원형)         | 개체의 성질, 정보               |
| **관계(Relationship)** | ◇ (마름모)         | 개체 간의 연관성                |
| **다중성**              | 1:1, 1\:N, N\:M | 관계의 수량 (카디널리티)           |


📌 속성 유형

| 종류     | 설명                             |
| ------ | ------------------------------ |
| 기본 속성  | 일반적인 속성 (ex: 이름, 나이)           |
| 키 속성   | 개체를 식별하는 고유한 값                 |
| 복합 속성  | 이름(성, 이름), 주소(시, 구 등)          |
| 다중값 속성 | 하나 이상의 값을 가질 수 있는 속성           |
| 유도 속성  | 계산으로 도출 (ex: 나이 = 현재연도 - 생년월일) |

---

### ✅ [2] 정규화 (Normalization)

#### 🔹 2-1. 정규화란?

📌 정의

- 데이터베이스 설계 과정에서 데이터 중복을 최소화하고, 이상 현상(Anomaly)을 제거하기 위한 과정

📌 목적

- 데이터의 일관성 유지


- 삽입·삭제·갱신 이상(Anomaly) 방지


- 데이터 중복 제거 및 무결성 향상


- 테이블 구조의 논리적 안정성 확보

---

#### 🔹 2-2. 이상 현상(Anomaly)의 종류

| 종류        | 설명                                                 |
| --------- | -------------------------------------------------- |
| **삽입 이상** | 일부 정보만 저장 불가 (예: 고객 없이 주문 불가)                      |
| **삭제 이상** | 한 정보 삭제 시 다른 정보도 함께 삭제 (예: 마지막 주문 삭제 시 고객 정보도 삭제됨) |
| **갱신 이상** | 동일한 정보가 여러 곳에 존재해 불일치 발생 가능성                       |

---

#### 🔹 2-3. 정규화의 단계
정규화는 기본적으로 1NF → 2NF → 3NF → BCNF 순으로 진행

✅ **(1) 제1정규형 (1NF: First Normal Form)**

📌 조건

- 속성 값은 반드시 원자값(Atomic Value) 이어야 한다.


- 한 셀에는 하나의 값만 있어야 함

📌 위반 예시

| 고객ID | 고객명 | 연락처                |
| ---- | --- | ------------------ |
| C001 | 홍길동 | 010-1111, 010-2222 |

→ 연락처에 2개의 값이 들어있으므로 1NF 위반

📌 해결 방법

→ 연락처를 행으로 나누거나 별도의 테이블로 분리

✅ **(2) 제2정규형 (2NF: Second Normal Form)**

📌 조건

- 1NF를 만족


- 부분 함수 종속 제거 (기본키의 일부 속성에만 종속된 속성 제거)

📌 함수 종속성(Function Dependency)

- A → B: A가 주어지면 B가 유일하게 결정됨

📌 위반 예시

기본키 = (학번, 과목코드)

| 학번   | 과목코드 | 과목명 |
| ---- | ---- | --- |
| 1001 | C101 | DB  |
| 1002 | C101 | DB  |

→ 과목명은 과목코드에만 종속됨 → 부분 종속 → 2NF 위반

📌 해결 방법

→ 과목 정보를 별도 테이블로 분리


✅ **(3) 제3정규형 (3NF: Third Normal Form)**

📌 조건

- 2NF를 만족


- 이행적 함수 종속 제거 (기본키가 아닌 속성을 통해 또 다른 속성이 결정되는 경우)

📌 위반 예시

기본키 = 학번

| 학번   | 학과코드 | 학과명    |
| ---- | ---- | ------ |
| 1001 | C01  | 컴퓨터공학과 |
| 1002 | C02  | 전자공학과  |

→ 학번 → 학과코드 → 학과명 → 이행적 종속

📌 해결 방법

→ 학과 정보를 별도 테이블로 분리

✅ **(4) BCNF (Boyce–Codd Normal Form)**

📌 조건

- 3NF를 만족


- 모든 결정자가 후보키 여야 함

📌 위반 예시

교수와 강의실이 고정된 수업

| 교수  | 강의실  | 과목명  |
| --- | ---- | ---- |
| 홍길동 | 101호 | 자료구조 |

`교수 → 강의실`

`강의실 → 교수`

→ 양방향 결정, 후보키가 아님 → BCNF 위반

📌 해결 방법

→ 교수를 기준으로 강의실 테이블, 과목명을 따로 분리

---

#### 🔹 2-4. 함수 종속성과 결정자

| 용어        | 설명                      |
| --------- | ----------------------- |
| **함수 종속** | A → B: A를 알면 B를 유일하게 결정 |
| **결정자**   | 종속 관계에서 왼쪽(A)           |
| **종속자**   | 종속 관계에서 오른쪽(B)          |
| **부분 종속** | 기본키의 일부분에만 종속           |
| **이행 종속** | A → B, B → C ⇒ A → C    |

---

### ✅ [3] 키(Key)

#### 🔹 3-1. 키란?

📌 정의

데이터베이스에서 **튜플(행)**을 고유하게 식별하기 위한 속성 또는 속성들의 집합

→ 즉, 레코드를 구분하는 기준

---

#### 🔹 3-2. 키의 종류

| 키 종류                    | 정의 및 특징                                         |
| ----------------------- | ----------------------------------------------- |
| **후보키 (Candidate Key)** | 튜플을 유일하게 식별할 수 있는 속성 집합<br>→ 유일성과 최소성을 만족       |
| **기본키 (Primary Key)**   | 후보키 중 선택된 하나<br>→ NULL 불가, 중복 불가                |
| **대체키 (Alternate Key)** | 후보키 중 기본키로 선택되지 않은 나머지 키                        |
| **슈퍼키 (Super Key)**     | 튜플을 유일하게 식별할 수 있는 속성들의 집합 (후보키 + 추가 속성 포함 가능)   |
| **외래키 (Foreign Key)**   | 다른 테이블의 기본키를 참조하는 키<br>→ 두 테이블 간 **관계 설정**에 사용됨 |

---

#### 🔹 3-3. 키 속성 요약

| 속성      | 슈퍼키 | 후보키 | 기본키 | 외래키       |
| ------- | --- | --- | --- | --------- |
| 유일성     | ✅   | ✅   | ✅   | ❌ (중복 가능) |
| 최소성     | ❌   | ✅   | ✅   | ❌         |
| NULL 허용 | 가능  | 가능  | ❌   | 가능        |
| 중복 허용   | 가능  | ❌   | ❌   | 가능        |

---

#### 🔹 3-4. 키 간 관계 구조

```scss
슈퍼키 ⊇ 후보키 ⊇ 기본키

기본키 ≠ 외래키 (외래키는 다른 테이블의 기본키 참조)
```

---

#### 🔹 3-5. 외래키 (Foreign Key)

📌 역할

- 다른 테이블과의 참조 관계 설정


- 참조 무결성 제약조건 설정 가능

📌 예시

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);
```

📌 외래키 동작 옵션

| 옵션                   | 의미                          |
| -------------------- | --------------------------- |
| `ON DELETE CASCADE`  | 부모 키 삭제 시 자식 데이터도 삭제        |
| `ON DELETE SET NULL` | 부모 키 삭제 시 자식의 외래키를 NULL로 설정 |
| `ON DELETE RESTRICT` | 부모 키 참조 중이면 삭제 불가           |

---

### ✅ [4] 트랜잭션(Transaction)

#### 🔹 4-1. 트랜잭션이란?

📌 정의

데이터베이스에서 하나의 논리적 작업 단위로 실행되어야 할 연산들의 집합

→ 하나의 트랜잭션은 여러 SQL 문장을 포함할 수 있으며, 전부 성공하거나 전부 실패해야 함

---

#### 🔹 4-2. 트랜잭션의 성질 – ACID

트랜잭션은 4가지 ACID 속성을 만족해야 함

| 속성                        | 설명                                    | 출제 포인트           |
| ------------------------- | ------------------------------------- | ---------------- |
| **A – 원자성 (Atomicity)**   | 트랜잭션의 작업은 **모두 수행되거나 모두 취소**되어야 함     | 실패 시 전체 ROLLBACK |
| **C – 일관성 (Consistency)** | 트랜잭션 수행 전후에 데이터의 **무결성이 유지**되어야 함     | 제약조건 위배 없도록      |
| **I – 격리성 (Isolation)**   | 여러 트랜잭션이 동시에 수행되더라도 **서로 간섭하지 않아야 함** | 동시성 제어 필요        |
| **D – 지속성 (Durability)**  | 성공한 트랜잭션 결과는 **영구히 저장**되어야 함          | 시스템 장애 후에도 유지    |

---

#### 🔹 4-3. 트랜잭션 명령어

| 명령어                            | 설명                       |
| ------------------------------ | ------------------------ |
| `BEGIN` 또는 `START TRANSACTION` | 트랜잭션 시작                  |
| `COMMIT`                       | 트랜잭션 **성공 → 영구 반영**      |
| `ROLLBACK`                     | 트랜잭션 **실패 시 → 변경 사항 취소** |
| `SAVEPOINT`                    | 중간 저장점 설정                |
| `ROLLBACK TO SAVEPOINT`        | 저장점 이후만 롤백               |

---

#### 🔹 4-4. 동시성 제어와 문제점

📌 동시성 제어 필요성

→ 여러 트랜잭션이 동시에 실행될 때, 데이터 불일치 방지

✅ 대표적인 동시 실행 문제

| 문제                              | 설명                                | 예시                                  |
| ------------------------------- | --------------------------------- | ----------------------------------- |
| **갱신 손실(Lost Update)**          | 두 트랜잭션이 같은 데이터를 수정 → 첫 수정 내용이 덮어씀 | T1과 T2가 같은 계좌 금액 변경                 |
| **읽기 현시점 오류(Dirty Read)**       | 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽음       | T1이 수정한 값을 T2가 참조                   |
| **비반복 읽기(Non-repeatable Read)** | 같은 쿼리를 두 번 했을 때 결과가 달라짐           | 중간에 다른 트랜잭션이 변경                     |
| **팬텀 읽기(Phantom Read)**         | 조건에 맞는 행이 처음엔 없었다가, 두 번째엔 나타남     | `WHERE salary > 5000` 조건에 새로운 행 추가됨 |

---

#### 🔹 4-5. 트랜잭션 격리 수준 (Isolation Level)

SQL 표준에서는 4단계의 격리 수준을 정의

| 수준                   | 허용되는 문제                | 설명                         |
| -------------------- | ---------------------- | -------------------------- |
| **READ UNCOMMITTED** | Dirty Read 허용          | 가장 낮은 수준, 성능은 좋음           |
| **READ COMMITTED**   | Non-repeatable Read 허용 | 대부분의 DBMS 기본값 (Oracle 등)   |
| **REPEATABLE READ**  | Phantom Read 허용        | 동일 행은 고정되지만 새로운 행은 보일 수 있음 |
| **SERIALIZABLE**     | 없음 (가장 엄격)             | 완벽한 직렬화, 성능 부담 큼           |

---

### ✅ [5] 무결성 제약조건 (Integrity Constraints)

#### 🔹 5-1. 무결성이란?

📌 정의

**무결성(Integrity)** 은 데이터의 정확성과 일관성을 보장하기 위한 제약 조건을 의미

데이터베이스에서 잘못된 값이 입력되거나 저장되는 것을 방지

---

#### 🔹 5-2. 무결성 제약조건의 분류

세 가지 핵심 무결성

| 종류          | 설명                                             | 적용 대상   |
| ----------- | ---------------------------------------------- | ------- |
| **도메인 무결성** | 열(column)의 데이터 값이 정해진 타입/범위/형식에 맞도록 제한         | 특정 속성 값 |
| **개체 무결성**  | 테이블 내 \*\*기본키(PK)\*\*는 NULL이거나 중복되면 안 됨        | 기본키(PK) |
| **참조 무결성**  | 외래키(FK)는 부모 테이블의 **기본키(PK)** 를 참조하거나 NULL이어야 함 | 외래키(FK) |

---

## 5. 데이터 저장 및 표현 방식

### ✅ [5-1] 자료 표현 – 2진수, 8진수, 16진수 변환

#### 🔹 1. 진법의 정의

| 진법                     | 설명               | 숫자 범위                   |
| ---------------------- | ---------------- | ----------------------- |
| **2진수 (Binary)**       | 0과 1 두 개의 숫자만 사용 | 0, 1                    |
| **8진수 (Octal)**        | 2진수 3자리씩 묶어서 표현  | 0\~7                    |
| **10진수 (Decimal)**     | 일상적으로 쓰는 수 체계    | 0\~9                    |
| **16진수 (Hexadecimal)** | 2진수 4자리씩 묶어서 표현  | 0~~9, A~~F (A=10, F=15) |

---

#### 🔹 2. 변환 방법 요약

✅ **(1) 2진수 → 10진수**

각 자리수에 2의 제곱을 곱한 후 모두 더함

> 1101₂ = (1×2³) + (1×2²) + (0×2¹) + (1×2⁰) = 8 + 4 + 0 + 1 = 13₁₀

✅ **(2) 10진수 → 2진수**

2로 나누며 나머지를 거꾸로 읽음

>13₁₀ → 1101₂
> 
>(13 ÷ 2 = 6 ...1 → 6 ÷ 2 = 3 ...0 → 3 ÷ 2 = 1 ...1 → 1 ÷ 2 = 0 ...1)

✅ **(3) 2진수 ↔ 8진수**

2진수 3자리씩 묶어서 변환

| 2진수 | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 8진수 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |

> 101011₂ = (101)(011) = 53₈

✅ **(4) 2진수 ↔ 16진수**

2진수 4자리씩 묶어서 변환


| 2진수  | 0000 | 0001 | 0010 | ... | 1111 |
| ---- | ---- | ---- | ---- | --- | ---- |
| 16진수 | 0    | 1    | 2    | ... | F    |

> 10101111₂ = (1010)(1111) = AF₁₆

---

### ✅ [5-2] 문자 인코딩 – ASCII, Unicode, UTF-8

#### 🔹 1. 문자 인코딩이란?

📌 정의

- **문자를 컴퓨터가 이해할 수 있도록 숫자로 바꾸는 규칙(코드 체계)**


- 모든 문자는 0과 1로 이루어진 이진수 코드로 저장되어야 컴퓨터가 처리

---

#### 🔹 2. 주요 문자 인코딩 방식 비교

| 인코딩         | 비트 수         | 표현 범위               | 특징                       |
| ----------- | ------------ | ------------------- | ------------------------ |
| **ASCII**   | 7비트          | 0\~127              | 미국 표준 문자 (영문자, 숫자, 특수기호) |
| **Unicode** | 16\~32비트     | 0\~약 110만자          | 전 세계 문자 통합               |
| **UTF-8**   | 가변 (1\~4바이트) | ASCII 포함 + 한글/중국어 등 | 웹 표준, 전 세계적 사용           |

---

#### 🔹 3. ASCII (American Standard Code for Information Interchange)

- 1960년대에 제정된 영문 중심 문자 코드


- 총 128개(0~127) 의 문자만 표현 가능


- 제어 문자 (0~31): 줄 바꿈, 벨 등


- 숫자 (4857): '0''9'


- 대문자 (6590): 'A''Z'


- 소문자 (97122): 'a''z'

📌 예시

| 문자  | ASCII 코드 (10진수) | 2진수 표현   |
| --- | --------------- | -------- |
| 'A' | 65              | 01000001 |
| 'a' | 97              | 01100001 |
| '0' | 48              | 00110000 |

---

#### 🔹 4. Unicode

- 전 세계의 문자를 하나의 코드 체계로 통일하기 위해 등장


- 16비트 이상을 사용하여 약 110만 개의 문자 지원


- 다양한 인코딩 방식 존재: UTF-8, UTF-16, UTF-32 등

---

#### 🔹 5. UTF-8 (8-bit Unicode Transformation Format)

📌 특징

- 가변 길이 인코딩 방식 (1~4바이트)


- ASCII(0~127)는 1바이트로 동일하게 유지


- 한글 등은 3바이트로 인코딩

📌 장점

- 영문 데이터는 ASCII 그대로 호환


- 저장공간 절약 가능


- 현재 웹/인터넷의 표준 인코딩 방식

📌 예시 (UTF-8 기준)

| 문자 | UTF-8 (16진수) | 바이트 수 |
| -- | ------------ | ----- |
| A  | 41           | 1     |
| 가  | EA B0 80     | 3     |
| 나  | EB 82 98     | 3     |
| 중  | EC A4 91     | 3     |

---

## 6. 보안

### 🔹 1. 암호화 방식

| 방식        | 특징                                          | 주요 알고리즘      |
| --------- | ------------------------------------------- | ------------ |
| **대칭키**   | 하나의 동일한 키로 암호화/복호화                          | AES, DES     |
| **비대칭키**  | 공개키(Public Key)로 암호화, 개인키(Private Key)로 복호화 | RSA          |
| **해시 함수** | 복호화 불가능한 일방향 암호화 (무결성 확인용)                  | SHA-256, MD5 |

---

### 🔹 2. 인증 기법

| 방식                          | 설명                               |
| --------------------------- | -------------------------------- |
| **ID/PW**                   | 가장 기본적인 방식, 사용자의 입력값 검증          |
| **OTP (One Time Password)** | 일회용 번호, 시간 기반 또는 서버 기반           |
| **생체 인증**                   | 지문, 홍채, 얼굴 등 물리적 특성 활용 (보안 강도 ↑) |

---

### 🔹 3. 공격 유형

| 공격 기법             | 설명                                        |
| ----------------- | ----------------------------------------- |
| **스푸핑(Spoofing)** | IP, 이메일 등을 **가짜로 위장**하여 속이는 공격            |
| **피싱(Phishing)**  | 가짜 웹사이트나 메일로 **개인정보 유도**                  |
| **스니핑(Sniffing)** | 네트워크를 **몰래 엿보며** 패킷/정보 수집                 |
| **DDoS**          | 수많은 좀비 PC를 이용해 **서버를 동시에 공격** (분산 서비스 거부) |
| **DoS**           | 단일 시스템에서 트래픽 과부하 유발                       |

| 항목     | DoS       | DDoS               |
| ------ | --------- | ------------------ |
| 공격 주체  | 단일 클라이언트  | 다수의 좀비 PC          |
| 방식     | 트래픽 폭주 유발 | 분산된 시스템을 이용한 동시 공격 |
| 대응 난이도 | 상대적으로 낮음  | 매우 높음 (분산 추적 어려움)  |


---

### 🔹 4. 악성코드 종류

| 종류          | 특징                                     |
| ----------- | -------------------------------------- |
| **바이러스**    | 프로그램에 기생, 실행 시 전파                      |
| **웜(Worm)** | 스스로 전파, **파일 감염 없이도** 네트워크 통해 확산       |
| **트로이 목마**  | 겉보기엔 정상 프로그램, 내부에 악성 기능 포함             |
| **랜섬웨어**    | 파일을 암호화하고 **몸값 요구** (현대 보안 위협 중 대표 사례) |

---

### 🔹 5. 방화벽(Firewall)

📌 기능

- 내부 네트워크와 외부 인터넷 사이에 위치


- 허용된 트래픽만 통과시키고 나머지는 차단

📌 필터링 기준

- IP, 포트, 프로토콜 기반 패킷 필터링


- 스테이트풀 인스펙션 기능 지원 가능 (상태 기반 추적)


---

### 🔹 6. 보안 프로토콜

| 프로토콜        | 설명                          |
| ----------- | --------------------------- |
| **HTTPS**   | HTTP + SSL/TLS → 암호화된 웹 통신  |
| **SSL/TLS** | 비대칭키 + 대칭키 조합, 전송 중 데이터 암호화 |