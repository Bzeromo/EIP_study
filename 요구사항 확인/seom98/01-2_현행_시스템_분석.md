# 현행 시스템 분석

# 현행 시스템 파악

## 1. 현행 시스템 파악 개념
- 현행 시스템 파악이란 <b>현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를</b> 파악하는 활동
- 사용하고 있는 <b>소프트웨어 및 하드웨어는 무엇인지</b>, 네트워크의 구성은 어떻게 되어 있는지 파악하는 활동

## 2. 현행 시스템 파악 절차
현행 시스템 파악을 위해 3단계의 절차가 필요
1. <b>구성/기능/인터페이스 파악</b>
- 시스템 구성 현황 파악
- 시스템 기능 파악
- 시스템 인터페이스 현황 파악

2. <b>아키텍처 및 소프트웨어 구성 파악</b>
- 아키텍처 파악
- 소프트웨어 구성 파악

3. <b>하드웨어 및 네트워크 구성 파악</b>
- 시스템 하드웨어 현황
- 네트워크 구성 파악

---

## 3. 소프트웨어 아키텍처

### 3-1. 소프트웨어 아키텍처(Software Architecture) 개념
소프트웨어 아키텍처는 <b>여러 가지 소프트웨어 구성 요소와 그 구성 요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체</b>를 말함

### 3-2. 소프트웨어 아키텍처 프레임워크(Framework)

#### 1. 소프트웨어 아키텍처 프레임워크 개념
- 소프트웨어 아키텍처 프레임워크는 <b>소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계</b>를 제공하는 아키텍처 기술 표준을 말함

#### 2. 소프트웨어 아키텍처 프레임워크 구성 요소
|구성 요소|설명|
|:---:|:---|
|<b>아키텍처 명세서</b><br>(Architectural<br>Description)|- 아키텍처리를 기록하기 위한 산출물들<br>이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현<br>개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음|
|<b>이해관계자</b><br>(Stakeholder)|- 시스템 개발에 관련된 모든 사람과 조직<br>- 고객, 최종 사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등을 포함함|
|<b>관심사</b><br>(Concerns)|- 시스템에 대해 이해관계짜들의 서로 다른 의견과 목표<br>- 사용자 입장, 유지보수자 입장, 개발자 입장이 있음<br><br>- 사용자 입장 : 기본적인 기능, 신뢰성 보안, 사용성 등의 품질<br>- 유지보수자 입장 : 유지보수의 용이성<br>~ 개발자 입장 : 적은 비용과 인력으로 개발|
|<b>관점</b><br>(Viewpoint)|- 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식<br>- 이해관계자들이 서로 다른 역할이나 책임으로 시스템이나 산출물들에 대해 보고 싶은 관점|
|<b>뷰</b><br>(View)|- 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현<br>- 시스템에 대한 아키텍처 설명에는 하나 이상의 뷰로 구성|
|<b>근거</b><br>(Rationale)|- 아키텍처 결정 근거<br>- 회의 결과, 보고 결과|
|<b>목표</b><br>(Mission)|- 환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용 운영 방법 등|
|<b>환경</b><br>(Environment)|- 시스템에 영향을 주는 요인으로 개발, 운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인|
|<b>시스템</b><br>(System)|- 각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등의 구현체|

### 3-3. 소프트웨어 아키텍처 4+1 뷰

#### 1. 소프트웨어 아키텍처 4+1뷰 개념
- 소프트웨어 아키텍처 4+1 뷰는 <b>고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는</b> 소프트웨어 접근 방법
- 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, <b>이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를</b> 증명하기 위해 체크 방법으로 <b>유스케이스</b> 사용

#### 2. 소프트웨어 아키텍처 4+1 뷰 구성요소
- 4+1에서 1은 유스케이스, 4는 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰임
 
<br>

![캡처](https://user-images.githubusercontent.com/87363461/230016012-a0f820cd-afbb-45fb-8011-583eee8f1b11.JPG)

<br>

#### 소프트웨어 아키텍처 4+1 뷰

|뷰|설명|
|:---:|:---|
|<b>유스케이스 뷰</b><br>(Usecase View)|- 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰<br>- 사용자, 설계자, 개발자, 테스트 관점|
|<b>논리 뷰</b><br>(Logical View)|- 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰<br>- 설계자, 개발자 관점|
|<b>프로세스 뷰</b><br>(Process View)|- 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰<br>- 개발자, 시스템 통합자 관점|
|<b>규현 뷰</b><br>(Implementation View)|- 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰<br>- 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의|
|<b>배포 뷰</b><br>(Deployment View)|컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰|

### 3-4. 소프트웨어 아키텍처 패턴(Pattern)

#### 1. 소프트웨어 아키텍처 패턴 개념
- 소프트웨어 아키텍처 패턴은 <b>소프트웨어를 설계할 때 참조할 수 있는 전형 적인 해결 방식</b>을 말함
- 주어진 상황에서의 소프트웨어 아키텍처에서 <b>일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션</b>을 말함

#### 2. 소프트웨어 아키텍처 패턴 필요성
- 소프트웨어 개발 시 상황별 소프트웨어 아키텍처 패턴을 수립 적용하여 <b>고객과 의사소통을 통해 고객의 요구사항을 만족시키고, 소프트웨어 개발 생산성과 품질 확보</b>가 가능함
- 개발에 대한 시행착오를 줄여 <b>개발 시간을 단축하고</b> <b>높은 품질의 소프트웨어 생산</b>이 가능
- 이미 검증된 구조로 개발하기 때문에 소프트웨어 개발을 안정적으로 수행할 수 있음
- 시스템의 특성을 개발 전에 예측이 가능함

#### 3. 소프트웨어 아키텍처 패턴 유형
- 소프트웨어 아키텍처 패턴의 주요 유형으로 계층화 패턴, 클라이언트-서버 패턴, 파이프 필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴 등이 있음

|유형|설명|개념도|
|:---:|:---|:---:|
|<b>계층화 패턴</b><br>(Layered<br>Pattern)|- 계층화 패턴은 시스템을 계층으로 구분하여 구성하는 패턴<br>- 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공<br>- 계층화 패턴은 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어짐|![image](https://user-images.githubusercontent.com/87363461/230023216-62f09853-383a-4042-aa04-1656f77a7f31.png)|
|<b>클라이언트-<br>서버 패턴</b><br>(Client-Server<br>Pattern)|- 클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된 패턴<br>-사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공br>- 서버는 계속 클라이언트로부터 요청을 대기|![image](https://user-images.githubusercontent.com/87363461/230023613-e84cc522-cb43-4563-85f4-ee5095697591.png)|
|<b>파이프-필터<br>패턴</b><br>(Pipe-Filter<br>Pattern)|- 파이브-핉터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴<br>- 파이프-필터 패턴은 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복<br>- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이함|![image](https://user-images.githubusercontent.com/87363461/230023850-6c6752fa-d698-4376-ab9b-656da92c9ec9.png)|
|<b>브로커 패턴</b><br>(Broker Pattern)|- 브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴<br>- 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행<br>- 서버는 자신의 기능들(서비스 및 특성)을 브로커에게 넘겨주며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스 리다이렉션함|![image](https://user-images.githubusercontent.com/87363461/230024294-9153a705-199a-4295-b1f4-c173cd0d4fad.png)|
|<b>모델-뷰-<br>컨트롤러<br>패턴</b><br>(MVC, Model<br>View Controller<br>Pattern)|- MVC 패턴이라고도 하며 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴<br>모델 : 핵심 기능과 데이터 보관<br>뷰 : 사용자에게 정보 표시나 이상의 뷰가 정의될 수 있음<br>컨트롤러 : 사용자로부터 요청을 입력받아 처리<br>- MVC 패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어 서로 영향을 받지 않고 개발 작업 수행 가능<br>MVC 패턴은 컴포넌트를 분리하며 코드의 효율적인 재사용성을 가능하게 하고, 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합|![image](https://user-images.githubusercontent.com/87363461/230024796-9b63857e-b6a4-46ce-9f96-513b8d17ee29.png)|

### 3-5. 소프트웨어 아키텍처 비용 평가 모델

#### 1. 소프트웨어 아키텍처 비용 평가 모델 개념
- 소프트웨어 아키텍처 비용 평가 모델은 <b>아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처 적합성을 평가하는 모델</b>을 말함

#### 2. 소프트웨어 아키텍처 비용 평가 모델 종류

![image](https://user-images.githubusercontent.com/87363461/230025007-e12620e9-5c24-46fd-8116-163ce35ef878.png)

|종류|설명|
|:---:|:---|
|<b>SAAM</b><br>(Software Architecture<br>Analysis Method)|변경 용이성과 경험이 없는 조직에서도 활용 가능한 비용 평가 모델|
|<b>ATAM</b><br>(Architecture Trade-off<br>Analysis Method)|<b>아키텍처 품질 속성</b>을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델|
|<b>CBAM</b><br>(Cost Benefit<br>Analysis Method)|ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델|
|<b>ADR</b><br>(Active Design Review)|소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델|
|<b>ARID</b><br>(Active Reviews for<br>Intermediate Designs)|전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델|

---

## 4. 디자인 패턴(Design Pattern)

### 4-1. 디자인 패턴 개념
- 디자인 패턴은 소프트웨어 공학의 <b>소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리</b>한 패턴
- 디자인 패턴을 참고하여 개발할 경우 <b>개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램의 최적화에 도움이 됨</b>

### 4-2. 디자인 패턴 구성요소
디자인 패턴에는 패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플 코드로 구성되어 있음

#### 디자인 패턴 구성요소
|구성요소|설명|
|:---:|:---|
|<b>패턴의 이름</b>|디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형|
|<b>문제 및 배경</b>|디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미|
|<b>솔루션</b>|디자인 패턴을 이루는 요소들, 관계, 협동 과정|
|<b>사례</b>|디자인 패턴의 간단한 적용 사례|
|<b>결과</b>|디자인 패턴을 사용하면 얻게 되는 이점이나 영향|
|<b>샘플 코드</b>|디자인 패턴이 적용된 원시 코드|

### 4-3. 디자인 패턴 유형

#### 목적 유형

|유형|설명|
|:---:|:---|
|<b>생성</b>|- 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴|
|<b>구조</b>|- 더 큰 구조 형성을 목적으로 클래스나 객체의 조합을 다루는 패턴|
|<b>행위</b>|- 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴|


#### 범위 유형

|유형|설명|
|:---:|:---|
|<b>클래스</b>|- 클래스 간 관련성(상속 관계를 다루는 패턴)<br>- <b>컴파일 타임</b>에 정적으로 결정|
|<b>객체</b>|- 객체 간 관련성을 다루는 패턴<br>- <b>런타임</b>에 동적으로 결정|

### 4-4 디자인 패턴 종류

#### 생성 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Builder</b>|- <b>복잡한 인스턴스를 조립하여 만드는 구조</b>로, 복합 객체를 생성할 때 <b>객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함</b>으로써 동일한 생성 절차에서 <b>서로 다른 표현 결과를 만들 수 있는</b> 디자인 패턴<br>- 생성과 표기를 분리해서 복잡한 객체를 생성|
|<b>Prototype</b>|- <b>처음부터 일반적인 원형을 만들어 놓고</b>, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 <b>객체를 생성할 때 갖추어야 할 기본 형태가 있을 때</b> 사용되는 디자인 패턴<br>- <b>기존 객체를 복제함으로써</b> 객체를 생성|
|<b>Factory Method</b>|- <b>상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 만드는 방식</b>으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 <b>함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성</b>을 갖는 디자인 패턴<br>- <b>생성할 객체의 클래스를 국한하지 않고</b> 객체를 생성|
|<b>Abstract Factory</b>|- 구체적인 클래스에 의존하지 않고 <b>서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공</b>하고 패턴으로 이 패턴을 통해 <b>생성된 클래스에서 사용자에게 인터페이스(API)를 제공</b>하고, 구체적인 구현은 Con-create Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴<br>- <b>동일한 주제의 다른 패토리를 묶음</b>|
|<b>Singleton</b>|<b>전역 변수를 사용하지 않고 객체를 하나만 생성</b>하도록 하며, 생성된 객체를 <b>어디에서든지 참조할 수 있도록</b> 하는 디자인 패턴<br>- <b>한 클래스에 한 객체만 존재</b>하도록 제한|


#### 구조 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Bridge</b>|- <b>기능의 클래스 계층과 구현의 클래스 계층을 연결</b>하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 <b>독립적으로 확장</b>할 수 있는 디자인 패턴<br>- 구현뿐만 아니라, <b>추상화된 부분까지 변경해야 하는 경우 활용</b>|
|<b>Decorator</b>|기존에 구현되어 있는 <b>클래스에 필요한 기능을 추가해 나가는 설계 패턴</b>으로, 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 <b>상속의 대안으로 사용하는</b> 디자인 패턴<br>- 객체의 결합을 통해 <b>기능을 동적으로 유연하게 확장</b>|
|<b>Facade</b>|- 복잡한 시스템에 대하여 <b>단순한 인터페이스를 제공</b>함으로써 사용자와 시스템 간 또는 여타 <b>시스템과의 결합도를 낮추어</b> 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴<br>- <b>통합된 인터페이스 제공</b>|
|<b>Facade</b>|- <b>복잡한 시스템에 대하여 단순한 인터페이스를 제공</b>함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 <b>시스템 구조에 대한 파악을 쉽게 하는 패턴</b>으로 오류에 대해서 단위별로 확인할 수 있게 하여 사용자의 측면에서 단순한 인터페이스 제공을 통해 <b>접근성을 높일 수 있는</b> 디자인 패턴<br>- <b>통합된 인터페이스 제공</b>|
|<b>Flyweight</b>|- 다수의 객체가 생성될 경우 모두가 갖는 <b>본질적인 요소를 클래스 화</b>하여 공유함으로써 메모리를 절약하고, <b>'클래스 경량화'를 목적</b>으로 하는 디자인 패턴<br>- 여러 개의 <b>'가상 인스턴스'</b>를 제공하여 메모리 절감|
|<b>Proxy</b>|- <b>'실체 객체에 대한 대리 객체'</b>로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 <b>실제 이용할 때 할당하게 하여</b> 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 <b>정보은닉의 역할도 수행</b>하는 디자인 패턴<br>- <b>특정 객체로의 접근을 제어</b>하기 위한 용도로 사용|
|<b>Composite</b>|- <b>객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴</b>으로, 사용자가 단일 <b>객체와 복합 객체 모두 동일하게 다루도록 하는 패턴</b><br>- 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 <b>타 클래스의 인터페이스를 기존 인터페이스에 덧씌움</b>|


#### 행위 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Mediator</b>|- 객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 <b>중재자</b>를 두고, 중재자에게 모든 것을 요구하여 <b>통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 디자인 패턴</b><br>- <b>상호 작용의 유연한 변경을 지원</b>|
|<b>Interpreter</b>|- 언어의 다양한 해석, 구체적으로 <b>구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성</b>하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴<br>- <b>문법 자체를 캡슐화</b>하여 사용|
|<b>Iterator</b>|- 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 <b>모든 항목에 반복자를 사용하여 접근</b>할 수 있는 디자인 패턴<br>- 내부구조를 노출하지 않고, <b>복잡 객체의 원소를 순차적으로 접근 가능하게 해주는</b> 행위 패턴|
|<b>Template<br>Method</b>|- 어떤 작업을 처리하는 일부분을 <b>서브 클래스로 캡슐화</b>해 전체 일을 수행하는 구조로 바꾸지 않으면서 <b>특정 단계에서 수행하는 내역을 바꾸는 패턴</b><br>- 일반적으로 상위 클래스에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 <b>코드 양을 줄이고 유지보수를 용이하게 만드는 특징</b>을 갖는 디자인 패턴<br>- 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행|
|<b>Observer</b>|- 한 <b>객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고</b> 자동으로 내용이 갱신되는 방법으로 <b>일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합</b>하는 디자인 패턴<br>- 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존|
|<b>State</b>|- <b>객체 상태를 캡슐화하여 클래스화</b>함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 <b>원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는</b> 디자인 패턴<br>- <b>객체 상태에 따라 행위 내용을 변경</b>|
|<b>Visitor</b>|- 각 클래스 데이터 구조로부터 <b>처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴</b>으로, 객체의 <b>구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용</b>하는 디자인 패턴<br>- 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위|
|<b>Command</b>|- <b>실행될 기능을 캡슐화함</b>으로써 주어진 여러 기능을 실행할 수 있는 <b>재사용성이 높은 클래스를 설계하는 패턴</b>으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴<br>- <b>요구사항을 객체로 캡슐화</b>|
|<b>Strategy</b>|- 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, <b>필요할 때 서로 교환해서 사용할 수 있게 하는 패턴</b>으로, 행위를 클래스로 캡슐화해 동적으로 행위를 <b>자유롭게 바꿀 수 있게 해주는 </b>디자인 패턴<br>- 행위 객체를 클래스로 캡슐화해 <b>동적으로 행위를 자유롭게 변환</b>|
|<b>Memento</b>|- 클래스 설계 관점에서 <b>객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴</b>으로 <b>Undo 기능을 개발할 때 사용</b>하는 디자인 패턴<br>- <b>객체를 이전 상태로 복구시켜야 하는 경우</b> 작업취소(Undo) 요청 기능|
|<b>Chain of<br>Responsibility</b>|- 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴<br>- <b>한 요청을 2개 이상의 객체에서 관리</b>|

<br>

---

<br>


# 개발 기술 환경 정의(:star::star::star:)

## 1. 개발 기술 환경 현행 시스템 분석

### 1-1. 운영체제 현행 시스템 분석

#### 1. 운영체제(Operating System)의 개념
- 운영체제는 <b>컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램</b>을 말함
- <b>사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 소프트웨어</b>

#### 2. 운영체제 현행 시스템 분석
- 운영체제 현행 시스템 분석 시 품질 측면과 지원 측면 등을 고려

#### 운영체제 현행 시스템 분석 시 고려 사항

|관점|고려사항|설명|
|:---:|:---:|:---|
|품질 측면|신뢰도|- 장기간 시슽메 운영 시 운영체제의 장애 발생 가능성<br>- 운영체제의 버그로 인한 재기동 여부|
|품질 측면|성능|- 대규모 및 대량 파일 작업(배치 작업)처리<br>- 지원 가능한 메모리 크기(32비트, 64비트)|
|지원 측면|기술 지원|- 공급사들의 안정적인 기술 지원<br>- 오픈 소스 여부|
|지원 측면|주변 기기|- 설치 가능한 하드웨어<br>- 다수의 주변 기기 지원 여부|
|지원 측면|구축 비용|- 지원 가능한 하드웨어 비용<br>- 설치할 응용 프로그램의 라이선스 정책 및 비용<br>- 유지 및 관리 비용|

### 3. 운영체제 종류 및 특징
- 대표적으로 PC, 모바일 운영체제로 나뉨

#### 운영체제 종류 및 특징

- 리눅스 기반 시스템이 하드웨어 및 소프트웨어 소유 비용이 가장 적게 소요됨

|구분|종류|저작자|특징|
|:---:|:---:|:---:|:---|
|PC|<b>윈도우즈</b><br>(Windows)|Microsoft|- 중/소규모 서버, 일단 PC 등 유지, 관리 비용 장점|
|PC|<b>유닉스</b><br>(UNIX)|IBM, HP, SUN|- 대용량 처리, 안정성 높은 엔터프라이즈급 서버|
|PC|<b>리눅스</b><br>(Linux)|Linus Torvalds|- 중/대규모 서버 대상, 높은 보안성 제공|
|Mobile|<b>안드로이드</b><br>(Android)|Google|- 리눅스 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제<br>- 개발자들이 자바, 코틀린 언어로 응용 프로그램을 작성할 수 있게 했고, 컴파일된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영체제|
|Mobile|<b>iOS</b>|Apple|- 스마트폰, 태블릿PC의 높은 보안성과 고성능 제공|

### 1-2. 네트워크 현행 시스템 분석

#### 1. 네트워크(Network)의 개념
- 네트워크는 <b>컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술</b>
- 데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이와 같은 무선 매체를 통해 확립됨

#### 2. OSI 7계층
- OSI 7계층은 네<b>트워크 통신에서 생긴 여러 가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델</b>

#### OSI 7계층 계층별 특징

|계층|설명|프로토콜|전송단위|
|:---:|:---|:---:|:---:|
|<b>응용 계층</b><br>(Application Layer)|- 사용자와 네트워크 간 응용서비스 연결, 데이터 생성|HTTP<br>FTP|데이터(Data)|
|<b>표현 계층</b><br>(Presentation Layer)|- 데이터 형식 설정과 부호교환, 암/복호화|JPEG<br>MPEG|데이터(Data)|
|<b>세션 계층</b><br>(Session Layer)|- 연결 접속 및 동기제어|SSH<br>TLS|데이터(Data)|
|<b>전송 계층</b><br>(Transport Layer)|- 신뢰성 있는 통신 보장<br>- 데이터 분할과 재조립, 흐름 제어, 오류 제어, 혼잡제어 등을 담당|TCP<br>UDP|세그먼트(Segment)|
|<b>네트워크 계층</b><br>(Network Layer)|- 단말기 간 데이터 전송을 위한 최적화된 경로 제공|IP<br>ICMP|패킷(Packet)|
|<b>데이터 링크 계층</b><br>(Data Link Layer)|- 인접 시스템 간 데이터 전송, 전송 오류 제어<br>- 동기화, 흐름 제어 등의 전송 기능 제공<br>- 오류 검출/재전송 등 기능 제공|이더넷<br>(Ethernet)|프레임(Frame)|
|<b>물리 계층</b><br>(Physical Layer)|- 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환|RS-232C|비트(Bit)|

#### 4. 네트워크 현행 시스템 분석
- 현행 시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석함
- 네트워크 구성도를 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있음
- <b>백본망, 라우터, 스위치, 게이트웨이, 방화벽</b>등을 대상으로 분석함
- 네트워크 분석 시 물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 가능함
- 네트워크 장애 발생 추적 및 대응 등의 다양한 용도로 활용 가능

### 1-3. DBMS(Database Management System) 현행 시스템 분석

#### 1. DBMS의 개념
- DBMS는 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
- DBMS의 기능은 중복 제어, 접근 통제, 인터페이스 제공, 관계 표현 등을 제공함

#### 2. DBMS의 기능

|기능|설명|
|:---:|:---|
|<b>중복 제어</b>|동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지|
|<b>접근 통제</b>|권한에 따라 데이터에 대한 접근 제어|
|<b>인터페이스 제공</b>|사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공|
|<b>관계 표현</b>|서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공|
|<b>샤딩/파티셔닝</b>|구조 최적화를 위해 작은 단위로 나누는 기능 제공|
|<b>무결성 제약 조건</b>|무결성에 관한 제약 조건을 정의/검사하는 기능 제공|
|<b>백업 및 회복</b>|데이터베이스 장애 발생 시 데이터의 보존 기능 제공|

#### 3. DBMS 현행 시스템 분석
- 데이터베이스의 가용성, 성능, 기술 지원, 호환성, 구축 비용을 분석함

#### DBMS 현행 시스템 분석 시 고려 사항

|관점|고려사항|설명|
|:---:|:---:|:---|
|<b>성능 측면</b>|<b>가용성</b>|- 장기간 시스템을 운영할 때 장애 발생 가능성<br>- 백업 및 복구 편의성<br>- DBMS 이중화 및 복제 지원 여부|
|<b>성능 측면</b>|<b>성능</b>|- 대규모 데이터 처리 성능<br>- 대량 거래 처리 성능<br>- 다양한 튜닝 옵션 지원 여부<br>- 비용 기반 최적화 지원 및 설정의 최소화 지원 여부|
|<b>성능 측면</b>|<b>상호 호환성</b>|- 설치 가능한 운영체제 종류<br>- 다양한 운영체제에서 지원되는 JDBC, ODBC|
|<b>지원 측면</b>|<b>기술 지원</b>|- 공급 업체들의 안정적인 기술 지원 여부<br>- 다수의 사용자 간의 정보 공유 여부<br>- 오픈 소스 여부|
|<b>지원 측면</b>|<b>구축 비용</b>|- 라이센스 정책 및 비용<br>- 유지 및 관리 비용|

### 1-4. 미들웨어의 현행 시스템 분석

#### 1.미들웨어(Middleware)의 개념
- 미들웨어는 <b>분산 컴퓨터 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어를 말함</b>
- 운영체제와 소프트웨어 애플리케이션 사이에 위치하고 있음
- 대표적인 미들웨어로 WAS가 있음

#### 2. 웹 애플리케이션 서버(Web Application Server)
- 웹 애플리케이션 서버는 서버계층에서 애플리케이션이 동작할 수 있도록 환경을 제공, 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스템과의 애플리케이션 연동을 지원하는 서버임

#### 3. 미들웨어의 현행 시스템 분석
- 미들웨어의 가용성, 성능, 기술 지원, 구축 비용을 분석함

#### 미들웨어 현행 시스템 분석 시 고려 사항
- 가용성
  - 장기간 시스템을 운영할 때 장애 발생 가능성
  - 안정적인 트랜잭션 처리 능력
  - WAS의 버그 등을 개선하는 패치 설치를 위한 재기동 기능 지원 여부
  - WAS 이중화 지원 여부
- 성능
  - 대규모 데이터 처리 성능
  - 다양한 설정 옵션 지원 여부
  - 가비지 컬렉션의 다양한 옵션 기능 여부
- 기술 지원
  - 공급 벤더들의 안정적인 기술 지원 여부
  - 다수의 사용자들 간의 정보 공유 여부
  - 오픈 소스 여부
- 구축 비용
  - 라이선스 정책 및 비용
  - 유지 및 관리 비용
  - 총 소유 비용

### 1-5. 오픈 소스 사용 시 고려 사항
- 오픈 소스를 사용하는 경우 <b>라이선스의 종류, 사용자 수, 기술의 지속 가능성 등</b>을 고려해야 함
- 오픈 소스 소프트웨어의 전제 조건인 자유 배포, 소스 코드 공개, 파생작업 허용, 소스 코드 일관성 확보, 차별금지, 라이선스 배포, 포괄적 허용을 고려해야 함


# 요구사항

## 1. 요구사항 개념

### 1-1. 요구공학(Requirements Engineering)의 개념
- 요구공학은 <b>사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동</b>을 말함

### 1-2. 요구공학의 목적
- 이해관계자 사이에 효과적인 의사소통 수단을 제공하고 시스템 개발의 요구사항에 대한 공통된 이해를 설정함
- 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용을 절감하고 요구사항 변경 추적을 가능하게 함
- 초기 요구사항 관리로 개발 비용과 시간을 절약하고 효과적인 의사소통 수단을 제공함

### 1-3. 요구사항의 분류
- 요구사항 파악의 기본은 시스템의 요구사항에 대한 파악임
- 요구사항은 <b>기능적 요구사항과 비기능적 요구사항으로 분류</b>됨

#### 요구사항의 분류

|구분|기능적 요구사항|비기능적 요구사항|
|:---:|:---|:---|
|<b>개념</b>|- 시스템이 제공하는 기능, 서비스에 대한 요구사항|- 시스템이 수행하는 기능 이외의 사항<br>- 시스템 구축에 대한 제약사항에 관한 요구사항|
|<b>도출 방법</b>|- 특정 입력에 대해 시스템이 어떻게 반응해야 하는지에 대한 기술<br>- 특정 상황에 대해 시스템이 어떻게 동작해야 하는지에 대한 기술|- 품질 속성에 관련하여 시스템이 갖춰야 할 사항에 관한 기술<br>- 시스템이 준수해야 할 제한 조건에 관한 기술|
|<b>특성</b>|- 기능성, 완전성, 일관성|- 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항|
|<b>사례</b>|- 온라인 홈페이지에서는 쇼핑카트에 주문 하고자 하는 품목을 저장할 수 있는 장바구니 기능을 제공해야 함|상품의 결제수단은 신용카드, 무통장 입금, 포인트 결제가 가능해야 함|

---

## 2. 요구공학 프로세스
- 요구공학 프로세스는 <b>요구사항 개발 단계와 요구사항 관리 단계</b>로 구성됨
  
![image](https://user-images.githubusercontent.com/87363461/230538737-fa49c23c-2ab8-4c2f-b3fc-4b5081e9a62a.png)
  
### 2-1. 요구사항 개발 단계 구성(CMM Level 3 프로세스 영역)

|순서|프로세스|설명|
|:---:|:---:|:---|
|1|<b>요구사항 도출</b><br>(Elicitation)|- 소프트웨어가 해결해야 할 문제를 이해하고, 고객으로부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집 방법 결정, 수집된 요구사항을 구체적으로 표현하는 단계<br>- 도출 단계에서 이해관계자가 식별되고, 개발팀과 고객 사이의 관계 형성되며 다양한 이해관계자와 효율적인 의사소통이 중요<br>- 주요 활동으로는 <b>고객 분석, 조직 환경 분석, 후보 요구사항 분류, 후보 요구사항 정제, 요구사항 소스 관리</b>가 있음|
|2|<b>요구사항 분석</b><br>(Analysis)|- 도출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계<br>- 요구사항들 간 상충되는 것을 해결하고, 소프트웨어의 범위를 파악하며, 소프트웨어가 환경과 어떻게 상호 작용하는지 이해하는 단계<br>- 주요 활동으로 <b>시스템 요구사항을 정제하여 소프트웨어 요구사항 분류, 후보 요구사항 모델링, 요구사항의 우선순위 부여, 해당 릴리즈에 수행할 요구사항 선정, 요구사항 협의</b>등이 있음|
|3|<b>요구사항 명세</b><br>(Specification)|- 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 단계<br>- 동의한 요구사항을 하나 이상의 형태로 저장하여 정형화된 요구사항을 생성하는 활동 수행<br>- 주요 활동으로 <b>요구사항 명세 기준 정의, 요구사항 명세서 작성, 요구사항 추적 관련 정보 저장</b> 등이 있음|
|4|<b>요구사항 확인 및 검증</b><br>(Validation &<br>Verification)|- 분석가가 요구사항을 이해했는지 확인(Validation)하고, 요구사항 문서가 회사의 표준에 적합하고 이해 가능하며, 일관성이 있고 완전한지 검증(Verification)하는 단계<br>- 요구사항 명세서 검토, 요구사항 용어 검증, 요구사항 베이스라인 수립<br>- 이해관계자들이 요구한 문서 검토 및 요구사항 관리 툴을 이용하여 요구사항 정의 문서들에 대한 형상 관리 수행<br>- 리소스가 요구사항에 할당되기 전에 문제를 파악하기 위하여 검증 수행|

### 2-2. 요구사항 개발 단계 상세

#### 1. 요구사항 도출 단계
- 요구사항 도출 단계는 <b>소프트웨어가 해결해야 할 문제를 이해하고, 고객으로부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집 방법 결정, 수집된 요구사항을 구체적으로 표현하는 단계</b>이다.

#### 요구사항 도출 단계 주요 기법
|주요 기법|설명|
|:---:|:---|
|<b>인터뷰</b><br>(Interview)|- 이해관계자와 직접 대화를 통해 정보를 구하는 공식적, 비공식적 정보 수집 방법|
|<b>브레인스토밍</b><br>(Brainstorming)|- 말을 꺼내기 쉬운 분위기로 만들어, 회의 참석자들이 내놓은 아이디어들을 비판없이 수용할 수 있도록 하는 회의|
|<b>델파이 기법</b><br>(Delphi<br>Method)|- 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 방법|
|<b>롤 플레잉</b><br>(Role Playing)|- 현실에 일어나는 장면을 설정하고 여러 사람이 각자가 맡은 역할을 연기함으로써 요구사항을 분석하고 수집하는 방법|
|<b>워크숍</b><br>(Workshop)|- 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법<br>- 프로젝트에 참여하는 모든 핵심 인물의 참여가 필요<br>- 참석자들은 해당 전문 영역별로 팀 협력이 필요하며 사전 준비가 요구됨|
|<b>설문 조사</b><br>(Survey)|- 설문지 또는 여론조사 등을 이용해 간접적으로 정보를 수집하는 방법<br>- 개발될 시스텡믜 사용자가 다수일 때 의견 수렴에 용이|

#### 2. 요구사항 분석 단계
- 요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계임

#### 요구사항 분석 단계 절차
|순서|절차|설명|
|:---:|:---:|:---|
|1|<b>요구사항<br>분류</b>|- 요구사항이 기능인지 비기능인지 활동<br>- 요구사항이 소프트웨어에 미치는 영향의 범위를 파악<br>- 요구사항이 소프트웨어 생명주기 동안 변경이 발생하는지를 확인<br>- 하나 이상의 상위 요구사항에서 유도된 것인지 또는 이해관계자나 다른 원천으로부터 직접 발생한 것인지 분류|
|2|<b>개념 모델링<br>생성 및 분석</b>|- 요구사항을 더 쉽게 이해할 수 있도록 현실 세계의 상황을 단순화, 개념적으로 표현한 것을 모델이라고 하며, 모델링은 이러한 모델을 만드는 활동임<br>- 개념 모델은 문제 도메인의 엔티티(Entitiy)들과 개별 관계 및 종속성을 반영<br>- 유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표기반 모델, 사용자 인터랙션, 객체 모델, 데이터 모델 등과 같은 다양한 개념 모델 작성 가능<br>- <b>모델링 표기는 주로 UML을 사용함</b>|
|3|<b>요구사항<br>할당</b>|- 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동<br>- 다른 구성요소와 어떻게 상호 작용하는지 분석을 통해 추가적인 요구사항 발견 가능|
|4|<b>요구사항<br>협상</b>|- 두 명의 이해관계자가 서로 상충되는 내용을 요구하는 경우, 어느 한쪽을 지지하기보다는 적절한 지점에서 합의하기 위한 활동<br>- 요구사항이 서로 충돌되는 경우 각각에 우선순위를 부여하면, 무엇이 더 중요한지를 인식할 수 있기 때문에 문제 해결에 도움이 됨|
|5|<b>정형 분석</b>|- 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현하는 활동<br>- 구문(Syntax)과 의미(Semantics)를 갖는 정형화된 언어를 사용하여 수학적 기호로 표현<br>- 요구사항 분석의 마지막 단계에서 이루어짐|

<br>

- 요구사항 분석 단계 기법에는 자료 흐름 지향 분석, 객체 지향 분석이 있음

#### 요구사항 분석 단계 기법
|기법|설명|
|:---:|:---|
|자료 흐름 지향 분석|데이터 흐름도 및 자료사전으로부터 소프트웨어 구조를 유도하는 방법|
|객체 지향 분석|시스템의 기능과 데이터를 함께 분석, UML로 표준화|

<br>

- 다양한 요구사항을 분석하기 위해서 청취 기술, 인터뷰와 질문 기술, 분석 기술, 중재 기술, 관찰 기술, 작성 기술, 조직 기술, 모델 작성 기술도 사용함

#### 요구사항 분석 기술
|분석 기술|설명|
|:---:|:---|
|<b>청취 기술</b>|이해관계자로부터 의견을 듣는 기술|
|<b>인터뷰와 질문 기술</b>|이해관계자를 만나 정보를 수집하고 이야기를 나누는 기술|
|<b>분석 기술</b>|추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 기술|
|<b>중재 기술</b>|이해관계자들의 상반된 요구에 대한 중재기술|
|<b>관찰 기술</b>|사용자가 작업하는 것을 관찰하면서 사용자가 언급하지 않은 미묘한 의미를 탐지할 수 있는 기술|
|<b>작성 기술</b>|문서 작성 기술|
|<b>조직 기술</b>|수집된 방대한 정보를 일관성 있는 정보로 구조화하는 능력|
|<b>모델 작성 기술</b>|수집한 자료를 바탕으로 제어의 흐름, 기능, 처리, 동작 행위, 정보 내용 등을 이해하기 쉽도록 모델로 작성하는 기술|

#### 3. 요구사항 명세 단계
- 요구사항 명세 단계는 <b>체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 단계</b>를 말함

#### 요구사항 명세 단계 주요 기법
|주요 기법|설명|
|:---:|:---|
|비정형<br>명세 기법|- 사용자의 요구를 표현할 때 자연어를 기반으로 서술하는 기법<br>- 사용자와 개발자의 이해가 용이함<br>- 명확성 및 검증에 문제|
|정형<br>명세 기법|- 사용자의 요구를 표현할 때 수학적인 원리와 표기법으로 서술하는 기법<br>- 정형 명세 언어인 Z-스키마, Petrl Nets, 상태차트 활용<br>- 표현히 간결함, 명확성 및 검증이 용이함<br>- 기법의 이해가 어려움|

<br>

- 요구사항 명세 단계의 산출물로 요구사항 명세서가 있음

#### 요구사항 명세 원리 및 검증 항목
|항목|설명|
|:---:|:---|
|<b>명확성</b>|각각의 요구사항에 명세 내용은 하나의 의미만 부여해야 함|
|<b>완전성</b>|기능, 성능, 속성, 인터페이스, 설계 제약 등에 관한 모든 시스템 요구사항이 포함되어야 함|
|<b>검증 가능성</b>|요구사항 내용의 충족 여부와 달성 정도에 대한 확인이 가능해야 함|
|<b>일관성</b>|요구사항의 내용 간 상호 모순이 없어야 함|
|<b>수정 용이성</b>|요구사항 변경 시 쉽게 수정 가능해야 함|
|<b>추적 가능성</b>|각 요구사항 근거에 대한 추적과 상호참조가 가능해야 함|
|<b>개발 후 용이성</b>|시스템 개발 후 운영 및 유지보수에 효과적인 이용이 가능해야 함|

#### 4. 요구사항 확인 및 검증 단계
- 요구사항 확인 및 검증은 <b>요구사항 명세서에 사용자의 요구가 올바르게 기술되었는지에 대한 검토, 베이스라인을 설정하는 활동</b>을 말함
- 프로젝트 참여자들이 요구사항을 이해했는지 확인(Validation)하고 요구사항 문서가 회사의 표준에 적합한지, 일관성을 만족하는지, 완전한지를 검증(Verification)해야 함
- 요구사항 명세서의 오류가 개발 단계나 운영 중인 상태에서 발견된다면 오류 수정 및 재작업 비용이 많이 소요되므로 요구사항 확인 및 검증은 반드시 필요함

#### 4-1. 요구사항 확인 및 검증 프로세스
- 요구사항 확인 및 검증 프로세스는 <b>요구사항 목록 확인, 요구사항 정의서 작성 여부 확인, 비기능적 요구사항의 확인, 타 시스템 연계 및 인터페이스 요구사항 확인</b> 순으로 되어있음

#### 요구사항 확인 및 검증 절차
|순서|절차|설명|
|:---:|:---:|:---|
|1|<b>요구사항<br>목록 확인</b>|- 요구사항 목록에서 업무 기능에 대한 요구사항 반영 여부 확인|
|2|<b>요구사항 정의서<br>작성 여부 확인</b>|- 요구사항 목록 중 수용인 경우, 요구사항 정의서가 작성되었는지 확인<br>- 요구사항 정의서에서 시스템의 동작 방식을 명확하고 구체적으로 기술하고 있는지 검토|
|3|<b>비기능적<br>요구사항의 확인</b>|- 시스템 특성, 품질 제약사항 등 비기능적 요구사항이 명확하게 도출되었는지 검토<br>- 성능, 가용성, 사용 용이성, 유지보수 용이성, 안전성, 보안성 등에 대한 요구사항의 문서화 여부 확인|
|4|<b>타 시스템 연계 및<br>인터페이스<br>요구사항 확인</b>|- 타 시스템 또는 하위 시스템 등과의 모든 인터페이스 요구사항이 정의되어 있는지 확인<br>- 인터페이스 구분(내부/외부), 주기, 방법, 제공자, 요청자 등이 명확하게 정의되어 있는지 확인|

<br>

- 아래와 같은 요구사항 정의서를 통해 요구사항 파악을 명확하게 할 수 있음

![image](https://user-images.githubusercontent.com/87363461/230574846-48e0b450-ad7f-4e6b-be44-caf311457936.png)

#### 요구사항 정의서 목록
|목록|검토 내용|
|:---:|:---|
|<b>ID</b>|명명 규칙에 따라 유일성이 확보되는 식별자가 부여되었는지 확인|
|<b>이름</b>|요구사항 내용을 요약하고, 중복되지 않았는지 확인|
|<b>유형</b>|기능, 비기능, 제약사항, 기타로 구분되어 있는지 확인|
|<b>품질 속성</b>|유형이 비기능일 때 품질 속성으로 성능, 가용성, 유지보수성, 신뢰성, 보안성,<br> 유지보수 용이성, 사용 용이성 등이 명시되어 있는지 확인|
|<b>우선순위</b>|필수, 선택, 희망 사항 등으로 구분되어 있는지 확인|
|<b>중요도</b>|작성 규칙에 따라 적절한 점수가 부여되어 있는지 확인|
|<b>출처</b>|요구사항을 낸 이해관계자의 이름이나 관련 문서명이 기술되어 있는지 확인|
|<b>관련 부서</b>|요구사항과 관련된 조직의 부서명이 기술되어 있는지 확인|
|<b>전제 조건</b>|요구사항과 관련된 전제 조건이 적절한지 확인|
|<b>내용</b>|요구사항의 내용이 명확하고 이해하기 쉽게 기술되어 있는지 확인|
|<b>관련 요구사항</b>|관련된 요구사항이 적절한지 확인|
|<b>버전</b>|요구사항의 변경 상태에 따라 버전이 관리되고 있는지 확인|
|<b>수용 여부</b>|검토 예정, 수용, 거부 등의 수용 여부 진행 상태가 기술되어 있는지 확인|


#### 4-2. 요구사항 확인 및 검증 단계의 주요 기법/산출물
-  요구사항 검토, 정형 기술 검토 활용, 프로토타이핑 활용, 모델 검증, 테스트 케이스 및 인수 테스트, CASE 도구 활용, 베이스라인, 요구사항 추적표가 있음

- <b>요구사항 검토</b>
  - 여러 검토자들이 에러, 잘못된 가정, 불명확성, 표준과의 차이 검토
  - 고객 중심 프로젝트에서는 검토자 그룹에 고객 대표자 1명 이상 포함 필요
  - 시스템 정의서, 시스템 사양서, 소프트웨어 요구사항 명세서를 완성한 시점에서 검토
- <b>정형 기술 검토 활용</b>
  - 정형 기술 검토 기법으로는 동료 검토, 워크 스루, 인스펙션이 있음
  - <b>동료 검토(Peer Review)</b>
    - 2 ~ 3명이 진행하는 리뷰의 형태
    - 요구사항 명세서 작성자가 요구사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토 방법
  - <b>워크 스루(Walk Through)</b>
    - 오류를 조기에 검출하는 데 목적이 있는 검토 방법
    - 검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서화하는 비공식적인 검토 방법
  - <b>인스펙션(Inspection)</b>
    - 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적인 검토 방법
    - 절차는 계획 -> 사전 교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속 조치 순서로 진행
- <b>프로토타이핑 활용</b>
  - 개발할 시스템에 대한 주요 기능이나 일부분을 개발하여 최종 사용자나 고객을 대상으로 시연하면서 시스템이 작동하는 모습을 경험할 수 있게 하여 요구사항을 확인
  - 요구사항이 잘못된 경우 유용한 피드백 제공
  - 사용자 인터페이스의 동적인 행위에 대한 이해가 문서나 그래픽 모델보다 용이함
- <b>모델 검증</b>
  - 분석단계에서 개발된 모델의 품질 검증 필요
  - 객체 모델의 경우 객체들 사이의 의사소통 경로를 검증하기 위한 정적 분석 수행에 유용
- <b>테스트 케이스 및 테스트를 통한 확인</b>
  - 요구사항의 중요한 속성은 최종 제품이 요구사항을 만족시키는지 확인 가능해야 함
  - 각각의 요구사항을 어떻게 확인할 것인지에 대한 계획을 수립하고 테스트 케이스 작성
  - 테스트 케이스를 생성한 후 단계별 테스트 및 인수 테스트에서 활용
  - 인수 테스트에는 알파 테스트와 베타 테스트가 있음
- <b>CASE 도구 활용 검증</b>
  - 구조화된 요구사항 명세서에 대해서는 자동화된 일관성 분석을 제공하는 CASE 도구 활용 가능
  - 대규모 개발 프로젝트에서는 다양한 이해관계자들이 요구사항 명셋서 검토가 필요하기 때문에, 요구사항 명세서에 대한 형상 관리 수행이 가능한 CASE 도구 이용
- <b>베이스라인을 통한 검증</b>
  - 요구사항 변경을 체계적으로 추적하고 통제하는 시점인 베이스라인을 통한 요구사항에 대한 지속적 검증 수행
- <b>요구사항 추적표(RTM, Requirement Traceability Matrix)</b>
  - 요구사항 정의서를 기준으로 개별단계별 최종 산출물이 어떻게 반영되고, 변경되었는지 확인이 가능한 문서
  
<br>

- 상세 정형 기술 검토 기법에는 <b>관리 리뷰, 기술 리뷰, 인스펙션, 워크스루, 감사</b>가 있음

|기법|설명|
|:---:|:---|
|<b>관리 리뷰</b><br>(Management<br>Review)|- 프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰|
|<b>기술 리뷰</b><br>(Technical<br>Review)|- 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰<br>- 변경 사항이 적절하게 구현되었는지를 평가하고, 여러 대안을 추천하거나 대안을 검토<br>- 대표 엔지니어가 주재하며 경우에 따라서 관리자도 참가 가능|
|<b>인스펙션</b><br>(Inspection)|- 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 색별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법<br>- 동료 검토(Peer Review)라고도 함|
|<b>워크 스루</b><br>(Walk Throught)|- 검토 자료를 회의 전에 배포해서 사전 검토 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 기법|
|<b>감사</b><br>(Audit)|- 소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고 있는지를 독립적으로 평가하는 기법<br>- 감사는 소프트웨어 제품의 제공자, 소비자, 제3기관이 수행|

### 2-3. 요구사항 관리 단계(CMM Level 2 프로세스 영역)
- 요구사항 관리는 <b>프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동</b>을 말함
- 주요 산출물로 <b>요구사항 변경요청서, 요구사항 변경승인서, 요구사항 추적표</b>가 있음

#### 요구사항 관리 단계 절차
|순서|절차|내용|기법/산출물|
|:---:|:---:|:---|:---:|
|1|<b>요구사항<br>협상</b>|가용한 자원과 수용 가능한 위험 수준에서 구현 가능한 기능을 협상하기 위한 기법|우선순위 설정,<br>시뮬레이션|
|2|<b>요구사항<br>기준선 설정</b>|공식적으로 검토되고 합의된 요구사항 명세서를 통해 기준선을 설정하기 위한 방법|공식 회의,<br>형상 관리|
|3|<b>요구사항<br>변경관리</b>|요구사항 기준선을 기반으로 모든 변경을 공식적으로 통제하기 위한 기법|형상통제 위원회,<br>영향도 분석|
|4|<b>요구사항<br>확인 및 검증</b>|구축된 시스템이 이해관계자가 기대한 요구사항에 부합하는지 확인하기 위한 방법|확인 및 검증|

<br>

---

<br>

# 요구사항의 시스템화 타당성 분석(:star:)
- 업무 분석가가 수집하고 분석한 요구사항이 개발하고자 하는 응용 소프트웨어에 미칠 영향을 대해서 검토하고 확인해야 함

## 1. 요구사항의 기술적 타당성 검토
- 요구사항의기술적 타당성 검토는 <b>성능 및 용량 산정의 적정성, 시스템 간 상호 운용성, IT 시장 성숙도 및 트렌드 부합성, 기술적 위험 분석</b>의 4단계를 거침

#### 요구사항 기술적 타당성 검토
|검토 항목|내용|
|:---:|:---|
|<b>성능 및 용량<br>산정의 적정성</b>|- 목표 시스템의 용량이 산정되면, 과거 유사 프로젝트 경험치를 적용하여 필요 시 재조정한 후, 성능 관련 비기능 요구사항과 비교하여 적정성 여부 판단|
|<b>시스템 간<br>상호 운용성</b>|- 요구사항 중에서 목표 시스템이 조직 내외 타 시스템과의 연동을 요구하는 경우, 상호 운용이 가능한지를 판단|
|<b>IT 시장 성숙도 및<br>트렌드 부합성</b>|- 시스템 구축 시 요구되는 영역별 기술들의 시장 성숙도 및 발전 방향을 파악하고, 요구사항이 이에 부합되는지 판단<br>- 향후 사용되지 않을 가능성이 높은 시스템들은 향후 유지보수가 어려운 상황이 발생|
|<b>기술적 위험 분석</b>|- 요구사항을 만족시키기 위하여 적용한 기술의 복잡성, 검증 여부, 의존성 등에 대하여 위험 발생 가능성 영향도 파악|


## 2. 요구사항의 기술적 타당성 분석 프로세스

|순서|분석 프로세스|설명|
|:---:|:---:|:---|
|1|<b>타당성 분석<br>결과 기록</b>|- 요구사항 목록에 타당성 분석을 위한 속성을 추가하고 타당성 분석 결과를 기록<br>- 타당성 분석을 위한 속성에는 성능/용량, 시스템 간 상호 운용성, 시장 성숙도 및 트렌드 부합성, 기술 복잡성, 기술 검증 여부, 기술 의존성 등이 있음|
|2|<b>타당성 분석 결과의<br>이해관계자 검증</b>|- 요구사항의 시스템화 타당성 분석 결과를 요구사항 관련 이해관계자에게 배포하여 사전 검토 요청<br>- 관련 이해관계자가 모여 시스템화 타당성 분석 결과 검증<br>- 타당성 분석 결과에 이견이 있는 경우 프로젝트 관리자의 중재 하에 합의 도출|
|3|<b>타당성 분석 결과<br>확인 및 배포/공유</b>|- 이해관계자 검증을 거친 타당성 분석 결과를 의사 결정자가 확인<br>- 확장된 타당성 분석 결과를 이해관계자에게 배포하여 공유|