***
# ⚡ 요구사항 확인
***


> [학습에 사용한 교재 (2025 시나공 퀵이지 정보처리기사 실기 단기완성)](https://www.aladin.co.kr/m/mproduct.aspx?ItemId=341611409&srsltid=AfmBOooInt5TDiPU-hLfwuLkPsx35KRQ1nN_mrbu2ujcfUtYH5JivYZl)

1. **`소프트웨어 생명 주기`**
    - 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것
    - 소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물로 표현
***

2. **`나선형 모형(점진적 모형)`**
    - 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형
    - `계획 수립` - `위험 분석` - `개발 및 검증` - `고객 평가` 순으로 반복

![](https://velog.velcdn.com/images/bzeromo/post/df0bc0b7-3656-4b57-abbf-03b602c10bc1/image.png)

> [예시 출처](https://itwiki.kr/w/%EB%82%98%EC%84%A0%ED%98%95_%EB%AA%A8%EB%8D%B8)

***

3. **`폭포수 모형(고전적 생명 주기 모형)`**
    - 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론

    ![](https://velog.velcdn.com/images/bzeromo/post/320cd2a4-3519-4f4f-a727-030ff8b3d721/image.png)

> [예시 출처](https://5dol.tistory.com/10)

***

4. **`애자일 모형`**
    - 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형
    - 특정 개발 방법론이 아니라 고객과의 소통에 초점을 맞춘 방법론을 통칭
    - `스크럼`, `XP`, `칸반`, `Lean`, `기능 중심 개발` 등

![](https://velog.velcdn.com/images/bzeromo/post/b75960a9-220f-4832-8de8-8d35a4816d1d/image.png)

> [예시 출처](https://velog.io/@finelinefe/CS-%EC%95%A0%EC%9E%90%EC%9D%BCAgile)

***

5. **`애자일 개발 4가지 핵심 가치`**
    - 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
    - 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
    - 계약 협상보다는 고객과 협업에 더 가치를 둔다.
    - 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.
   
***

6. **`소프트웨어 공학`**
    - 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문

    - **소프트웨어 공학의 기본 원칙**
      1) 현대적인 프로그래밍 기술을 계속적으로 적용해야한다.
      2) 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야한다.
      3) 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야한다.
    
***  

7. **`스크럼 개발 프로세스`**

|**프로세스**|**내용**
|:---:|:---:|
|**스프린트 계획 회의**|제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의
|**스프린트**|실제 개발 작업을 진행하는 과정으로, 보통 2~4주 정도의 기간 내에서 진행
|**일일 스크럼 회의**|모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 상황을 점검하는 회의, 남은 작업 시간은 번다운 차트에 표시
|**스프린트 검토 회의**|부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의
|**스프린트 회고**|정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것

***

8. **`XP(eXtreme Programming)`**
    - 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법

    -   |**5가지 핵심 가치(의단용존피)**|
                |:---:|
        |**의사소통**|
        |**단순성**|
        |**용기**|
        |**존중**|
        |**피드백**|

***

9. **`XP의 주요 실천 방법`**

    1) `Pair Programming`
       - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다.

    2) `Collective Ownership`
       - 개발 코드에 대한 권한과 책임을 공동으로 소유한다.

    3) `Test-Driven Development`
       - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악한다.
       - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 구조(구조, 프레임워크)를 사용한다.

    4) `Whole Team`
       - 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 한다.

    5) `Continuous Integration(CI)`
       - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합된다.

    6) `Refactoring`
       - 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위해 프로그램의 기능의 변경 없이 시스템을 재구성한다.

    7) `Small Releases`
       - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다.

***

10. **`데이터베이스 관리 시스템(DBMS)`**
    - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어
    -   |**요구사항 식별 시 고려사항(가성기상구)**|
                |:---:|
        |**가용성**|
        |**성능**|
        |**기술 지원**|
        |**상호 호환성**|
        |**구축 비용**|

***

11. **`기능 요구사항`**
    - **시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항**
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는 지에 대한 사항
    - 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능

***

12. **`비기능 요구사항`**
    - **품질이나 제약사항과 관련된 요구사항**
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터를 구축하기 위해 필요한 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 제약사항
    - 프로젝트 관리 요구사항
    - 프로젝트 자원 요구사항
    - 품질 요구사항: `가용성`, `정합성`, `대응성`, `보안성`, `상호 호환성`, `이식성`, `확장성` 등

***

13. **`요구사항 명세 기법`**

|**구분**|**정형 명세 기법**|**비정형 명세 기법**
|:---:|:---:|:---:|
|**기법**|수학적 원리 기반, 모델 기반|상태/기능/객체 중심
|**작성 방법**|수학적 기호, 정형화된 표기법|일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성
|**특징**|요구 사항을 정확하고 간결하게 표현, 결과가 일관성이 있어 완전성 검증이 가능, 표기법이 어려움|자연어 사용으로 인해 요구사항 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고 해석이 달라질 수 있지만 이해가 쉬워 의사소통이 용이함
|**종류**|`VDM`, `Z`, `Petri-net`, `CSP` 등|`FSM`, `Decision Table`, `ER Modeling`, `State Chart` 등 

***

14. **`요구사항 개발 프로세스`**
    - 개발 대상에 대한 요구사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동
    - 진행되기 전에 타당성 조사가 선행되어야 함
    - `도출` - `분석` - `명세` - `확인`

---

15. **`요구사항 분석`**
    - 소프트웨어 개발의 실제적인 첫 단계로, 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동
    - 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정

---

16. **`자료 흐름도(DFD)`**
    - 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
    - 자료 흐름 그래프, 버블 차트라고도 한다.

![](https://velog.velcdn.com/images/bzeromo/post/f20ee590-da07-48f3-9bc6-ecc53784510d/image.png)

> [예시 출처](http://ecampus.keris.or.kr/cyber/9/CD2/lecture_16/1605_p1.htm#)

---

17. **`자료 흐름도의 구성 요소(프자자단)`**

|**기호**|**의미**
|:---:|:---:|
|**프로세스**|자료를 변환시키는 시스템의 한 부분을 나타내며 처리, 기능, 변환, 버블이라고도 함
|**자료 흐름**|자료의 이동이나 연관관계를 나타냄
|**자료 저장소**|시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냄
|**단말**|시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음

---

18. **`자료 사전(메타 데이터)`**
    - 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
    - |**기호**|**의미**
            |:---:|:---:|
      |**=**|`자료의 정의`: ~로 구성되어 있다
      |**+**|`자료의 연결`: 그리고
      |**()**|`자료의 생략`: 생략 가능한 자료
      |**[]**|`자료의 선택`: 또는
      |**{}**|`자료의 반복`: Iteration of
      |*** ***|`자료의 설명`: 주석|

---

19. **`SADT`**
    - 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구
    - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구

---

20. **`HIPO`**
    - 시스템의 분석 및 설계, 또는 문서화에 사용되는 기법
    - 시스템 실행 과정인 입력/처리/출력의 기능을 표현한 것
    - 하향식 소프트웨어 개발을 위한 문서화 도구
    - `HIPO Chart`

    ![](https://velog.velcdn.com/images/bzeromo/post/ed3ceb44-eaa4-47d6-945c-4f3bbc8f4c5a/image.png)

> [예시 출처](https://velog.io/@finelinefe/CS-%EC%95%A0%EC%9E%90%EC%9D%BCAgile)

---

21. **`UML`**
    - 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
    -   |**UML의 구성 요소(사관다)**|
                |:---:|
        |**사물**|
        |**관계**|
        |**다이어그램**|

---

22. **`연관 관계`**
    - 2개 이상의 사물이 서로 연관되어 있는 관계
    - 사물 사이를 실선으로 연결하여 표현하며 방향성은 화살표로 표현
    - 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결
    - 다중도를 선 위에 표기

    ![](https://velog.velcdn.com/images/bzeromo/post/f8430ac4-3cd5-4903-be89-25af3ec4b443/image.png)

> [예시 출처](https://kji6252.github.io/2017/01/15/jpa-basic-04/)

---

23. **`집합 관계`**
    - 하나의 사물이 다른 사물에 포함되어 있는 관계
    - 포함하는 쪽과 포함되는 쪽은 서로 독립적이다.
    - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/c206d0c4-3cbd-4a57-a60e-6ba74fc94106/image.png)

> [예시 출처](https://velog.io/@e_juhee/Class-Diagram)

---

24. **`포함 관계`**
    - 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
    - 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기를 함께한다.
    - 집합 관계와 다르게 속이 채워진 마름모를 연결하여 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/1e6d045b-893a-45f2-adc2-d5577c982699/image.png)

> [예시 출처](https://velog.io/@e_juhee/Class-Diagram)

---

25. **`일반화 관계`**
    - 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
    - 일반적인 개념을 상위 혹은 부모라고 부르고 더 구체적인 개념을 하위 혹은 자식이라고 부른다.
    - 하위에서 상위 쪽으로 빈 화살표를 연결하여 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/13d11157-eb56-48c9-9230-fc76c8299b41/image.png)

> [예시 출처](https://velog.io/@e_juhee/Class-Diagram)

---

26. **`의존 관계`**
    - 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
    - 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계
    - 영향을 주는 사물이 영향을 받는 사물 쪽으로 점선 화살표를 연결하여 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/a7a8f4a1-d886-4553-b296-1238a9bca44a/image.png)

> [예시 출처](https://velog.io/@e_juhee/Class-Diagram)

---

27. **`실체화 관계`**
    - 사물이 할 수 있거나 해야하는 기능, 서로를 그룹화 할 수 있는 관계
    - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계
    - 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현
    - **인터페이스!**

    ![](https://velog.velcdn.com/images/bzeromo/post/dd302d88-0635-4d4e-9408-2c237087329e/image.png)

> [예시 출처](https://velog.io/@e_juhee/Class-Diagram)

---

28. **`다이어그램`**
    - 사물과 관계를 도형으로 표현한 것
    - 여러 관점에서 시스템을 가시화한 뷰를 제공하여 의사소통에 도움을 줌
    - 정적 모델링에서는 구조적 다이어그램을, 동적 모델링에서는 행위 다이어그램을 주로 사용

---

29. **`구조적 다이어그램의 종류`**

    1) **클래스 다이어그램**
       - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/b0d93589-4d64-4766-812a-1d81f266037b/image.png)

    > [예시 출처](https://brownbears.tistory.com/577)

    2) **객체 다이어그램**
       - 클래스에 속한 객체들(인스턴스)을 특정 시점의 객체와 객체 사이의 관계로 표현
       - 럼바우 객체지향 분석 기법에서 객체 모델링에 활용

    ![](https://velog.velcdn.com/images/bzeromo/post/cc1a36d0-0a80-4fbf-981f-8487c1f82eb1/image.png)

    > [예시 출처](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8)

    3) **컴포넌트 다이어그램**
       - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
       - 구현 단계에서 사용

    ![](https://velog.velcdn.com/images/bzeromo/post/10413c91-4995-4b3c-8cfa-ee50c371331d/image.png)

    > [예시 출처](https://ocwokocw.tistory.com/101)

    4) **배치 다이어그램**
       - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
       - 구현 단계에서 사용

    ![](https://velog.velcdn.com/images/bzeromo/post/07a870a3-5056-468b-87d0-12a1ded099fd/image.png)

    > [예시 출처](https://ocwokocw.tistory.com/24)

    5) **복합체 구조 다이어그램**
       - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/65a696d1-32e7-4e0a-820d-57d0a37df09b/image.png)

    > [예시 출처](https://ocwokocw.tistory.com/100)

    6) **패키지 다이어그램**
       - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/f0b390bb-d9f9-4b28-a84e-2727785db74d/image.png)

    > [예시 출처](https://beluga9.tistory.com/55)

---

30. **`행위 다이어그램의 종류`**

    1) **유스케이스 다이어그램**
       - 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용
       - 사용자와 사용 사례로 구성

    ![](https://velog.velcdn.com/images/bzeromo/post/5fa12709-9872-4185-b1be-31ffbf178243/image.png)

    > [예시 출처](https://narup.tistory.com/70)

    2) **순차 다이어그램**
       - 상호작용하는 시스템이나 객체들이 주고받는 메시지를 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/52aa605a-cfde-4573-9b48-9d7812a37ee7/image.png)

    > [예시 출처](https://itwiki.kr/w/%EC%8B%9C%ED%80%80%EC%8A%A4_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8)

    3) **커뮤니케이션 다이어그램**
       - 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현

    ![](https://velog.velcdn.com/images/bzeromo/post/bc64e2ee-a031-4122-a8f3-58bc688992d7/image.png)

    > [예시 출처](https://ocwokocw.tistory.com/97)

    4) **상태 다이어그램**
       - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는 지를 표현
       - 럼바우 객체지향 분석 기법에서 동적 모델링에 활용

    ![](https://velog.velcdn.com/images/bzeromo/post/bc3803cf-7ac8-4e97-8e50-6eaeee1ecaf5/image.png)

    > [예시 출처](https://ko-de-dev-green.tistory.com/96)

    5) **활동 다이어그램**
       - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
       - 플로우 차트와 비슷해서 헷갈릴 수도 있을듯 하다...

    ![](https://velog.velcdn.com/images/bzeromo/post/dd5c7b1a-61fe-4008-8dbb-258326e7650d/image.png)

    > [예시 출처](https://online.visual-paradigm.com/ko/diagrams/templates/activity-diagram/uml-activity-diagram/)

    6) **상호작용 개요 다이어그램**
    - 상호작용 다이어그램 간의 제어 흐름을 표현

    7) **타이밍 다이어그램**
    - 객체 상태 변화와 시간 제약을 명시적으로 표현

---

31. **`스테레오 타입`**
    - UML에서 표현하는 기능 외에 추가적인 기능을 표현하는 것
    - 길러멧이라고 부르는 겹화살괄호(《》) 사이에 표현할 형태를 기술한다.

---

32. **`유스케이스 다이어그램`**
    - 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**시스템/시스템 범위**|시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것
      |**액터**|시스템과 상호작용을 하는 모든 외부 요소로 주로 사람이나 외부 시스템을 의미
      |**유스케이스**|사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것
      |**관계**|액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며 `포함 관계`, `확장 관계`, `일반화 관계`로 나뉨

   ![](https://velog.velcdn.com/images/bzeromo/post/fdcb245d-1d28-4dc9-ab5b-13aa98033300/image.png)

> [예시 출처](https://velog.io/@vomw99/UML-%EC%9C%A0%EC%8A%A4%EC%BC%80%EC%9D%B4%EC%8A%A4-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8Usecase-Diagram)

---

33. **`유스케이스에서 나타날 수 있는 관계`**
    - |**포함 관계**|두 개 이상의 유스케이스에 공통적으로 적용되는 기능을 별도로 분리하여 새로운 유스케이스로 만든 경우, 원래의 유스케이스와 새롭게 분리된 유스케이스와의 관계를 말함
      |:---:|:---:|
      |**확장 관계**|**유스케이스가 특정 조건에 부합되어 유스케이스의 기능이 확장될 때 원래의 유스케이스와 확장된 유스케이스와의 관계를 말함**

---

34. **`활동 다이어그램`**
    - 사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**액션/액티비티**|각각 더 이상 분해할 수 없는 단일 작업과 몇 개의 액션으로 분리될 수 있는 작업을 의미
      |**시작 노드**|액션이나 액티비티가 시작됨을 표현한 것
      |**종료 노드**|액티비티 안의 모든 흐름이 종료됨을 표현한 것
      |**조건(판단) 노드**|조건에 따라 제어의 흐름이 분리됨을 표현한 것, 들어오는 제어 흐름은 한 개이고 나가는 제어 흐름은 여러 개
      |**병합 노드**|여러 경로의 흐름이 하나로 합쳐짐을 표현한 것, 들어오는 제어 흐름은 여러 개이고 나가는 제어 흐름은 한 개
      |**포크(Fork) 노드**|액티비티의 흐름이 분리되어 수행됨을 표현한 것, 들어오는 액티비티 흐름은 한 개이고 나가는 액티비티 흐름은 여러 개
      |**조인(Join) 노드**|분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현한 것, 들어오는 액티비티 흐름은 여러 개이고 나가는 액티비티 흐름은 한 개
      |**스윔레인**|액티비티 수행을 담당하는 주체를 구분하는 선, 가로 또는 세로 실선

   ![](https://velog.velcdn.com/images/bzeromo/post/c38f39bb-3275-4425-bf92-a623b809bbb1/image.png)

> [예시 출처](https://ko.wikipedia.org/wiki/%ED%99%9C%EB%8F%99_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8)

---

35. **`클래스 다이어그램`**
    - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**클래스**|각각의 객체들이 갖는 속성과 오퍼레이션을 표현한 것, 이름과 속성, 오퍼레이션으로 3개의 구획을 나눔
      |**제약 조건**|속성에 입력될 값에 대한 제약 조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적으며 클래스 안에 기술할 때는 중괄호를 이용
      |**관계**|클래스와 클래스 사이의 연관성을 표현, `연관`, `집합`, `포함`, `일반화`, `의존` 관계가 있음

   ![](https://velog.velcdn.com/images/bzeromo/post/0cceaf28-64d0-4fa7-8a5c-d222a557ce67/image.png)

> [예시 출처](https://www.mindonmap.com/ko/blog/what-is-uml-class-diagram/)

---

36. **`연관 클래스`**
    - 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
    - 두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시
    - 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정


---

37. **`순차 다이어그램`**
    - 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정을 그림으로 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**액터**|시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미
      |**객체**|메시지를 주고받는 주체
      |**생명선**|객체가 메모리에 존재하는 기간으로 객체 아래쪽에 점선을 그어 표현, 객체 소멸(`X`)이 표현된 기간까지 존재
      |**실행 상자(활성 상자)**|객체가 메시지를 주고받으며 구동되고 있음을 표현
      |**메시지**|객체가 상호 작용을 위해 주고받는 메시지
      |**객체 소멸**|해당 객체가 더 이상 메모리에 존재하지 않음을 표현한 것
      |**프레임**|다이어그램의 전체 또는 일부를 묶어 표현한 것

   ![](https://velog.velcdn.com/images/bzeromo/post/47bd5221-4a7c-4110-b332-5e886ab9fd43/image.png)

   > _이 예시에는 객체 소멸 표시가 없다._

> [예시 출처](https://velog.io/@wansook0316/Sequence-Diagram)

---

38. **`커뮤니케이션 다이어그램`**
    - 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**액터**|시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미
      |**객체**|메시지를 주고받는 주체
      |**링크**|객체들 간의 관계를 표현한 것, 액터와 객체, 객체와 객체 간에 실선을 그어 표현
      |**메시지**|객체가 상호작용을 위해 주고받는 내용, 화살표의 방향은 메시지를 받는 쪽으로 향하게 표현

   ![](https://velog.velcdn.com/images/bzeromo/post/81f7baba-c14d-4f4c-86a0-e7f28c5413ef/image.png)

> [예시 출처](https://velog.io/@yooha9621/UML%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8UML%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8-%EC%A2%85%EB%A5%981)

---

39. **`상태 다이어그램`**
    - 객체들 사이에서 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**상태**|객체의 상태를 표현한 것
      |**시작 상태**|상태의 시작을 표현한 것
      |**종료 상태**|상태의 종료를 표현한 것
      |**상태 전환**|상태 사이의 흐름, 변화를 화살표로 표현한 것
      |**이벤트**|상태에 변화를 주는 현상, `조건`, `외부 신호`, `시간의 흐름` 등이 있음
      |**프레임**|상태 다이어그램의 범위를 표현한 것

   ![](https://velog.velcdn.com/images/bzeromo/post/35ed35c0-81d3-4069-9045-a81fbe6c0342/image.png)

> [예시 출처](https://velog.io/@_dodo_hee/%EC%84%B8%EB%AF%B8%EB%82%98-UML-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8)

---

40. **`패키지 다이어그램`**
    - 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존관계를 표현한 것

    - |**구성 요소**|**내용**
      |:---:|:---:|
      |**패키지**|객체들을 그룹화한 것, 패키지 이름만 표현하는 단순 표기법과 요소까지 표현하는 확장 표기법이 있다
      |**객체**|유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들
      |**의존 관계**|패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현, 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며 대표적으로 `import`와 `access`를 사용

   ![](https://velog.velcdn.com/images/bzeromo/post/ee02f456-5add-42c4-9bbe-256dc8e95c03/image.png)

> [예시 출처](https://online.visual-paradigm.com/ko/diagrams/templates/package-diagram/package-diagram-overview/)

---

41. **`구조적 방법론`**
    - 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론
    - 이해가 쉽고 검증이 가능한 프로그램 코드를 생성하는 것이 목적
    - `타당성 검토` - `계획` - `요구사항` - `설계` - `구현` - `시험` - `운용/유지보수`

---

42. **`컴포넌트 기반 방법론`**
    - 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
    - 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있음
    - `개발 준비` - `분석` - `설계` - `구현` - `테스트` - `전개` - `인도
    
---

43. **`소프트웨어 재사용`**
    - 이미 개발되어 인정받는 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
    - `합성 중심`: 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법
    - `생성 중심`: 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법

---

44. **`CASE(Computer Aided Software Engineering)`**
    - 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것
    - **주요 기능**

        - 소프트웨어 생명 주기 전 단계의 연결
        - 다양한 소프트웨어 개발 모형 지원
        - 그래픽 지원

---

45. **`LOC 기법`**
    - 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
    - **산정 공식**

        - `노력(인월)` = `개발 기간` X `투입 인원` = `LOC` / `1인당 월평균 생산 코드 라인 수`
        - `개발 비용` = `노력(인월)` X `단위 비용(1인당 월평균 인건비)`
        - `개발 기간` = `노력(인월)` X `투입 인원`
        - `생산성` = `LOC` / `노력(인월)`

---

46. **`수학적 산정 기법`**
    - 상향식 비용 산정 기법으로, 개발 비용 산정의 자동화를 목표로 함
    - `경험적`, `실험적 추정 모형` 이라고도 함
    - `COCOMO 모형`, `Putnam 모형`, `기능 점수(FP) 모형`

---

47. **`COCOMO 모형`**
    - 원시 프로그램의 규모인 `LOC`에 의한 비용 산정 기법
    - 개발할 소프트웨어의 규모(`LOC`)를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정함
    - 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(`Man-Month`)으로 나타남

---

48. **`COCOMO의 소프트웨어 개발 유형`**
    - **조직형**

        - 기관 내부에서 개발된 중 내부에서 개발된 중·소 규모의 소프트웨어
        - 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등의 5만 라인 이하의 소프트웨어를 개발하는 유형
        - 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합

    - **반분리형**

        - 조직형과 내장형의 중간형 소프트웨어
        - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만 라인 이하의 소프트웨어를 개발하는 유형
        - 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합

    - **내장형**

        - 초대형 규모의 소프트웨어
        - 트랜잭션 처리 시스템이나 운영체제 등의 30만 라인 이상의 소프트웨어를 개발하는 유형
        - 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합

---

49. **`Putnam 모형(생명 주기 예측 모형)`**
    - 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
    - 시간에 따른 함수로 표현되는 `Rayleigh-Norden 곡선`의 노력 분포도를 기초로 함

    ![](https://velog.velcdn.com/images/bzeromo/post/e6d1db0e-5a7c-4351-8778-cda97ea7b86c/image.png)

> [예시 출처](https://www.javatpoint.com/putnam-resource-allocation-model)

---

50. **`기능 점수 모형`**

    - 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용하여 비용을 산정하는 기법
    - **소프트웨어 기능 증대 요인**

        - 자료 입력(입력 양식)
        - 정보 출력(출력 보고서)
        - 명령어(사용자 질의수)
        - 데이터 파일
        - 필요한 외부 루틴과의 인터페이스

---

51. **`비용 산정 자동화 추정 도구`**
    - |||
      |:---:|:---:|
      |**SLIM**|`Rayleigh-Norden 곡선`과 `Putnam` 예측 모델을 기초로 하여 개발된 자동화 추정 도구
      |**ESTIMACS**|다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구

---

52. **`PERT`**
    - 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크
    - 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음
    - 낙관적인 경우, 가능성이 있는 경우, 비관적인 경우로 단계를 나누어 종료시기를 결정

---

53. **`CPM`**
    - 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
    - 노드와 간선으로 구성된 네트워크로 노드는 작업을, 간선은 작업 사이의 전후 의존 관계를 나타냄.
    - 최장 경로를 임계 경로라고 함

---

54. **`간트 차트`**
    - 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표
    - 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 함

---

55. **`ISP/IEC 12207`**
    - `ISO(국제표준화기구)`에서 만든 표준 소프트웨어 생명 주기 프로세스
    - 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공함
    - |||
      |:---:|:---:|
      |**기본 생명 주기 프로세스**|획득, 공급, 개발, 운영, 유지보수 프로세스
      |**지원 생명 주기 프로세스**|품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상관리, 문제 해결 프로세스
      |**조직 생명 주기 프로세스**|관리, 기반 구조, 훈련, 개선 프로세스

---

56. **`CMMI`**
    - 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
    - 프로세스 성숙도를 단계별로 나눈다. `(초관정정최)`

    - |단계|특징
      |:---:|:---:|
      |**초기**|작업자 능력에 따라 성공 여부 결정
      |**관리**|특정한 프로젝트 내의 프로세스 정의 및 수행
      |**정의**|조직의 표준 프로세스를 활용하여 업무 수행
      |**정량적 관리**|프로젝트를 정량적으로 관리 및 통제
      |**최적화**|프로세스 역량 향상을 위해 지속적인 프로세스 개선

---

57. **`SPICE(ISO/IEC 15504)`**
    - 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

---

58. **`SPICE의 프로세스 수행 능력 단계(불수관확예최)`**
    - |수준|단계|특징
      |:---:|:---:|:---:|
      |0|**불완전**|프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계
      |1|**수행**|프로세스가 수행되고 목적이 달성된 단계
      |2|**관리**|정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계
      |3|**확립**|소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계
      |4|**예측**|프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계
      |5|**최적화**|프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계

---

59. **`소프트웨어 개발 방법론 테일러링`**
    - 프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업이다.
    - 고려사항은 다음과 같다.

    - |기준|내용
      |:---:|:---:|
      |**내부적 기준**|목표 환경, 요구사항, 프로젝트 규모, 보유 기술
      |**외부적 기준**|법적 제약사항, 표준 품질 기준

---

60. **`소프트웨어 개발 프레임워크`**
    - 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템

---

61. **`소프트웨어 개발 프레임워크의 특성`**

    - `모듈화`: 프레임워크는 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킨다.

    - `재사용성`: 프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능하다.

    - `확장성`: 프레임워크는 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.

    - `제어의 역흐름`: 개발자가 관리하고 통제해야하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킨다.

---