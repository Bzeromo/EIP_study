***
# ⚡ 데이터 입출력 구현
***

### 1. **`DBMS`**
    
- 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
 

- 정의 기능, 조작 기능, 제어 기능 (D,M,C)

---

### 2. **`스키마`**
    
- 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것

- |**종류**|**내용**
  |:---:|:---:|
  |**외부 스키마**|사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
  |**개념 스키마**|데이터베이스의 전체적인 논리적 구조, 하나만 존재
  |**내부 스키마**|물리적 저장장치의 입장에서 본 데이터베이스 구조

---

### 3. **`데이터베이스 설계 순서`**
    
- `요구조건 분석` - `개념적 설계` - `논리적 설계` - `물리적 설계` - `구현`

---

### 4. **`개념적 설계`**
    
- 정보의 구조를 얻기 위해서 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정


- 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행


- ERD 작성
---
### 5. **`논리적 설계`**
    
- 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정


- 개념 스키마를 평가 및 정제, DBMS에 따라 서로 다른 논리적 스키마를 설계
---
### 6. **`물리적 설계`**
    
- 논리적 설계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정


- 저장 레코드의 형식, 순서, 접근 경로 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사

---

### 7. **`데이터 모델`**

- 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형


- |**요소**|**내용**
  |:---:|:---:|
  |**구조**|논리적으로 표현된 개체 타입들 간의 관계
  |**연산**|데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
  |**제약 조건**|데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
---
### 8. **`E-R 다이어그램`**
    
- |**기호**|**의미**
      |:---:|:---:|
      |**사각형**|개체 타입
      |**마름모**|관계 타입
      |**타원**|속성
      |**이중 타원**|다중 값 속성
      |**밑줄 타원**|기본키 속성
      |**복수 타원**|복합 속성
      |**관계**|1:1 등의 개체 간 관계에 대한 대응 수를 선 위에 표시
      |**선, 링크**|개체 타입과 속성을 연결

   ![](https://velog.velcdn.com/images/bzeromo/post/d7b849e3-1da0-4465-8431-f4ea58d2a78f/image.png)

> [예시 출처](https://programinglab.tistory.com/164)

---
### 9. **`관계형 데이터베이스의 릴레이션 구조`**
    
- `릴레이션`: 데이터들을 표의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성


- `릴레이션 인스턴스`: 데이터 개체를 구성하고 있는 속성들에 데이터 타입이 정의되어 구체적인 데이터 값을 가진 것

   ![](https://velog.velcdn.com/images/bzeromo/post/a97b3071-ef3f-434c-a318-f6d23a766ee1/image.png)

> [예시 출처](https://velog.io/@yellowbutter0327/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%82%A4%EB%A7%88-%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%86%8D%EC%84%B1-%ED%8A%9C%ED%94%8C-ze31wk4s)
---
### 10. **`튜플`**

- 릴레이션을 구성하는 각각의 행


- 튜플의 수를 `카디널리티` 또는 `기수`, `대응수`라고 함
---
### 11. **`속성`**
    
- 데이터베이스를 구성하는 가장 작은 논리적 단위


- 개체의 특성을 기술


- 속성의 수를 `디그리` 또는 `차수`라고 함
---
### 12. **`도메인`**

- 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합


- 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용
---

### 13. **`후보키`**
    
- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합


- 기본키로 사용할 수 있는 속성들


- 유일성과 최소성을 모두 만족시켜야 함

  - |||
    |:---:|:---:|
    |**유일성**|하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다
    |**최소성**|키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 한다
---
### 14. **`기본키(PK)`**
    
- 후보키 중에서 특별히 선정된 주키


- 중복된 값 금지, NULL 값 금지
---
### 15. **`대체키(보조키)`**
- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
---
### 16. **`슈퍼키`**
    
- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키


- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음


- 모든 튜플에 대해 유일성은 만족하지만 최소성은 만족하지 못함
---
### 17. **`외래키(FK)`**
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
---
### 18. **`무결성`**
    
- 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성

- |||
  |:---:|:---:|
  |**개체 무결성**|기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다
  |**참조 무결성**|릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다
---
### 19. **`관계 대수`**
    
- 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어


- 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하며, 피연산자와 연산 결과가 모두 릴레이션


- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시
---
### 20. **`순수 관계 연산자`**
    
- |이름|설명|기호
      |:---:|:---:|:---:|
      |**`Select(수평 연산)`**|릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산|σ
      |**`Project(수직 연산자)`**|주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산|π
      |**`Join`**|공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산|⋈
      |**`Division`**|Y가 X의 부분집합인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산|÷

---
### 21. **`일반 집합 연산자`**
    
- |이름|설명|기호
      |:---:|:---:|:---:|
      |**`Union(합집합)`**|두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산|∪
      |**`Intersection(교집합)`**|두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산|∩
      |**`Difference(차집합)`**|두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산|-
      |**`Cartesian Product(교차곱)`**|두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산, 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음|x

---
### 22. **`관계해석`**
    
- 관계 데이터의 연산을 표현하는 방법


- 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님


- 원하는 정보를 정의할 때는 계산 수식을 사용
---
### 23. **`이상(Anomaly)`**
    
- 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상

- |||
  |:---:|:---:|
  |**삽입 이상**|의도와는 상관없이 원하지 않은 값들로 인해 테이블에 데이터를 삽입할 수 없게 되는 현상
  |**삭제 이상**|테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들이 연쇄 삭제되는 현상
  |**갱신 이상**|테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상

---
### 24. **`함수적 종속`**

- |                                                      ||
      |:----------------------------------------------------:|:---:|
      |          **함수적 종속(Functional Dependency)**           |속성 X의 값 각각에 대해 항상 속성 Y의 값이 오직 하나만 연관되어있을 때 Y는 X에 함수적 종속된다고 함, X → Y
      |            **완전 함수적 종속(Full Dependency)**            |속성 집합 X 전체에 대해 함수적 종속이면서 X의 다른 진부분 집합 중 어떤 집합에도 함수적 종속이 아닐 때를 말함
      |          **부분 함수적 종속(Partial Dependency)**           |완전 함수적 종속과 다르게 전체에 종속이면서 일부에도 함수적 종속일 때를 말함
      |        **이행적 함수적 종속(Transitive Dependency)**         |X → Y 이고, Y → Z일 때, X → Z를 만족하는 관계
---
### 25. **`정규화`**
    
- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정


- 가능한 한 중복을 제거하여 이상 발생 가능성을 줄이는 것을 목표로 함
---
### 26. **`정규화 과정`**
    
> [참고](https://minimax95.tistory.com/entry/%EC%A0%95%EA%B7%9C%ED%99%94Normalization-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EA%B3%BC%EC%A0%95)

- `제 1 정규형`: 테이블의 모든 속성 값이 원자 값으로만 되어 있는 정규형


- `제 2 정규형`: 테이블이 제 1 정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형


- `제 3 정규형`: 테이블이 제 2 정규형이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형
 

- `BCNF`: 테이블에서 모든 결정자가 후보키인 정규형, 제 3 정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능


- `제 4 정규형`: 테이블에 `다중 값 종속` A →→ B가 존재할 경우 테이블의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형


- `제 5 정규형`: 테이블의 모든 `조인 종속`이 테이블의 후보키를 통해서만 성립되는 정규형

    > 💡 `다중 값 종속(다치 종속)` <br>
_A, B, C 3개의 속성을 가진 테이블 R에서 어떤 복합 속성(A, C)에 대응하는 B 값의 집합이 A 값에만 종속되고 C 값에는 무관하면, B는 A에 다중 값 종속이라 함_

    > 💡 `조인 종속` <br>
_어떤 테이블 R의 속성에 대한 부분 집합 X, Y, ..., Z가 있을 때 만약 테이블 R이 자신의 프로젝션 X, Y, ..., Z를 모두 조인한 결과와 동일한 경우 테이블 R은 조인 종속 JD(X, Y, ..., Z)를 만족한다고 함_
---

### 27. **`정규화 과정 정리(도부이결다조)`**
    
- `비정규 릴레이션` → `1NF` → `2NF` → `3NF` → `BCNF` → `4NF` → `5NF`


- `도`메인이 원자값 → `부`분적 함수 종속 제거 → `이`행적 함수 종속 제거 → `결`정자이면서 후보키가 아닌 것 제거 → `다`치 종속 제거 → `조`인 종속성 이용
---
### 28. **`반정규화`**
    
- 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화 된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
---
### 29. **`중복 테이블 추가`**
    
- 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것


- 집계 테이블, 진행 테이블, 특정 부분만을 포함하는 테이블의 추가로 이루어짐
---
### 30. **`시스템 카탈로그`**
    
- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스


- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블임


- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로 카탈로그를 데이터 사전이라고 함
---
### 31. **`트랜잭션`**
    
- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들


- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용
---
### 32. **`트랜잭션의 특성(원일독영)`**
    
- |특성|의미
      |:---:|:---:|
      |**원자성**|트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료되든지 아니면 복구되어야 함
      |**일관성**|트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
      |**독립성, 격리성, 순차성**|둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
      |**영속성, 지속성**|성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함
---
### 33. **`CRUD 분석`**
    
- 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것
---
### 34. **`인덱스`**
    
- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
---
### 35. **`뷰`**
    
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블


- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨


- 정의할 때는 `CREATE`, 제거할 때는 `DROP`
---
### 36. **`파티션의 종류`**
    
- |||
      |:---:|:---:|
      |**범위 분할**|지정한 열의 값을 기준으로 분할
      |**해시 분할**|해시 함수를 적용한 결과 값에 따라 데이터를 분할
      |**조합 분할**|범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
---
### 37. **`분산 데이터베이스의 목표(위중병장)`**
    
- |||
      |:---:|:---:|
      |**위치 투명성**|액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음
      |**중복 투명성**|동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
      |**병행 투명성**|분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
      |**장애 투명성**|트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리함

---

### 38. **`RTO/RPO`**
    
- |||
      |:---:|:---:|
      |**RTO(목표 복구 시간)**|비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간
      |**RPO(목표 복구 시점)**|비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점
---
### 39. **`암호화`**
    
- 데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것


- `복호화 과정`: 암호문을 원래의 평문으로 바꾸는 과정


- `개인키 암호 방식`과 `공개키 암호 방식`이 있음

---

### 40. **`임의 접근통제(DAC)`**
    
- 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식


- 데이터 소유자가 접근통제 권한을 지정하고 제어함
---
### 41. **`강제 접근통제(MAC)`**
    
- 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식


- 시스템이 접근통제 권한을 지정
---
### 42. **`역할기반 접근통제(RBAC)`**
    
- 사용자의 역할에 따라 접근 권한을 부여하는 방식


- 중앙관리자가 접근통제 권한을 지정


- 다른 두 접근통제 기법의 단점을 보완하고 다중 프로그래밍 환경에 최적화됨
---
### 43. **`DAS(Direct Attached Storage)`**
    
- 서버와 저장장치를 전용 케이블로 직접 연결하는 방식


- 직접 연결 방식이므로 다른 서버에서 접근하거나 파일을 공유할 수 없음
---
### 44. **`NAS(Network Attached Storage)`**
    
- 서버와 저장장치를 네트워크를 통해 연결하는 방식


- 이더넷 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능
---
### 45. **`SAN(Storage Area Network)`**
    
- `DAS`의 빠른 처리와 `NAS`의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식


- 파이버 채널 스위치를 이용하여 네트워크를 구성, 서버들이 저장장치 및 파일을 공유할 수 있다.


- 광케이블로 연결하므로 처리 속도가 빠름
---
### 46. 트리 순회법(Tree Traversal)

- 트리는 노드를 방문하는 순서에 따라 다음과 같은 방식으로 순회할 수 있다.

| 순회 방법                 | 정의         | 순서 (Root 기준)        |
| --------------------- | ---------- | ------------------- |
| **전위 순회 (Preorder)**  | 루트를 먼저 방문  | Root → Left → Right |
| **중위 순회 (Inorder)**   | 왼쪽 방문 후 루트 | Left → Root → Right |
| **후위 순회 (Postorder)** | 자식 방문 후 루트 | Left → Right → Root |

예시 트리
```mathematica
    A
   / \
  B   C
 / \   \
D   E   F
```
| 순회 방식     | 결과          |
| --------- | ----------- |
| Preorder  | A B D E C F |
| Inorder   | D B E A C F |
| Postorder | D E B F C A |

---

### 47. 수식 표기법(Notation)

- | 표기법     | 예시 (a + b × c) | 연산자 위치      | 설명                      |
  | ------- | -------------- | ----------- | ----------------------- |
  | Infix   | a + b × c      | 연산자가 **중간** | 일반적 수학 표현식              |
  | Prefix  | + a × b c      | 연산자가 **앞**  | Polish Notation         |
  | Postfix | a b c × +      | 연산자가 **뒤**  | Reverse Polish Notation |

---

### 48. Infix ↔ Prefix/Postfix 변환 방법

#### 🔁 Infix → Postfix (중위 → 후위)

변환 규칙 (스택 이용):

- 피연산자는 그대로 출력

- 연산자는 우선순위를 고려하여 스택에 push

- 괄호는 별도로 처리:

    - (는 무조건 push

    - )를 만나면 (가 나올 때까지 pop하여 출력

예제:

```r
Infix   : a + b * c
Postfix : a b c * +
```

#### 🔁 Infix → Prefix (중위 → 전위)


- Infix를 거꾸로(reverse) 읽는다

- 괄호 방향도 반대로 변경 (여는 → 닫는)

- 그 상태에서 Postfix로 변환

- 결과를 다시 거꾸로(reverse) 하면 Prefix

예제:

```r
Infix   : a + b * c
→ 거꾸로 : c * b + a
→ Postfix: c b * a +
→ 역순  : + a * b c (Prefix)
```

#### 🔁 Postfix → Infix (후위 → 중위)

변환 규칙 (스택 이용):

- 피연산자는 스택에 push

- 연산자를 만나면 → 스택에서 두 개 pop → "(" + 피연산자1 + 연산자 + 피연산자2 + ")" 형태로 묶어서 push

예제:

```perl
Postfix : a b c * +
스택 진행:
1. a → push
2. b → push
3. c → push
4. * → pop(c), pop(b) → (b * c) → push
5. + → pop((b * c)), pop(a) → (a + (b * c)) → push

결과: (a + (b * c))
```
---

### 49. 연산자 우선순위

- | 연산자         | 우선순위  | 결합 방향 |
  | ----------- | ----- | ----- |
  | `(` `)`     | 가장 높음 | -     |
  | `*` `/` `%` | 2     | 왼쪽부터  |
  | `+` `-`     | 1     | 왼쪽부터  |

---

### 50. **`삽입 정렬`**
    
- 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식


- 평균: `O(n²)`


- 최악: `O(n²)`
---
### 51. **`선택 정렬`**
    
- n개의 레코드 중에서 최소 값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 n-1개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식


- 평균: `O(n²)`


- 최악: `O(n²)`
---
### 52. **`버블 정렬`**
    
- 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 교환하는 정렬 방식


- 평균: `O(n²)`


- 최악: `O(n²)`
---
### 53. **`퀵 정렬`**
    
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬


- 분할과 정복, 피봇을 사용함


- 최악: `n(n-1)/2`
---
### 54. **`힙 정렬`**
    
- 전이진 트리를 이용한 정렬 방식


- 평균: `O(nlog2n)`


- 최악: `O(nlog2n)`
---
### 55. **`2-Way 합병 정렬`**
    
- 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식


- 평균: `O(nlog2n)`


- 최악: `O(nlog2n)`
