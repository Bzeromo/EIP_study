# ✅ 6. 화면설계(UI 요구사항 및 설계, 표준 프로토 타입 제작 등)

# UI 요구사항 확인

# UI란?

넓은 의미에서는 사용자와 시스템 간 의소소통 하게 해주는 물리적 가상 매개체 전부

좁은 의미에서는 정보 기기나 소프트웨어 화면 등에서 사용자가 접하는 화면

UX는 UI를 포함하고 있음(사용자 경험 > 사용자 인터페이스)

## 유형

| **유형** | **특징** | **설명** |
| --- | --- | --- |
| CLI 
(Command Line Interface) | 정적인 텍스트 기반 인터페이스 | -명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스 |
| GUI 
(Graphical User Interface) | 그래픽 반응 기반 인터페이스 | -그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스 |
| NUI 
(Natural User Interface) | 직관적 사용자 반응 기반 인터페이스 | -키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
-터치, 음성 포함 |
| OUI 
(Organic User Interface) | 유기적 상호 작용 기반 인터페이스 | -현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스 |

## 분야

물리적 제어 분야 - 정보 제공과 기능 전달을 위한 하드웨어

디자인적 분야 - 콘텐츠의 정확하고 상세한 표현과 전체적 구성

기능적 분야 - 사용자의 편의성에 맞춰 쉽고 간편하게 사용 가능

## 설계 원칙

| **설계 원칙** | **설명** | **부특성** |
| --- | --- | --- |
| 직관성 
(Intuitiveness) | 누구나 쉽게 이해하고, 
쉽게 사용할 수 있어야 함 | -쉬운 검색
-쉬운 사용성
-일관성 |
| 유효성 
(Efficiency) | 정확하고 완벽하게 
사용자의 목표가 달성될 수 있도록 제작 | -쉬운 오류 처리 및 복구 |
| 학습성 
(Learnability) | 초보와 숙련자 모두가 
쉽게 배우고 사용할 수 있게 제작 | -쉽게 학습
-쉬운 접근
-쉽게 기억 |
| 유연성 
(Flexibility) | 사용자의 요구사항을 최대한 수용하고, 실수를 방지할 수 있도록 제작 | -오류 예방 및 감지
-실수 포용 |

## 설계 지침

| **설계 지침** | **설명** |
| --- | --- |
| 사용자 중심 | 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공하며, 
실사용자에 대한 이해가 바탕이 되어야함 |
| 일관성 | 버튼이나 조작 방법을 사용자가 
기억하기 쉽고 빠르게 습득할 수 있도록 설계해야 함 |
| 단순성 | 조작 방법은 가장 간단하게 작동되도록 하여
인지적 부담 최소화 |
| 결과 예측 가능 | 작동시킬 기능만 보고도
결과 예측이 가능해야 함 |
| 가시성 | 주요 기능을 메인 화면에 노출하여
쉬운 조작이 가능해야 함 |
| 표준화 | 디자인을 표준화하여
기능구조의 선행 학습 이후 쉽게 사용 가능해야 함 |
| 접근성 | 사용자의 직무, 연령, 성별 등이 고려된
다양한 계층을 수용해야 함 |
| 명확성 | 사용자가 개념적으로 쉽게 인지해야 함 |
| 오류 발생 해결 | 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함 |

## 요구 사항 확인

사용자가 정보시스템을 구축하여 얻고자 하는 최종 목적의 기준

요구사항은 시스템 개발 과정 전체에 대한 기준 & 종료 후 검수의 기준

## 요구 사항 구분

### 기능적

- 시스템이 제공하는 기능, 서비스에 대한 요구사항
- 시스템의 입출력, 데이터, 연산에 관한 요구사항

### 비기능적

- 사용성, 효율성, 신뢰성, 유지보수성, 재사용성 등 품질에 관한 요구사항
- 플랫폼, 사용 기술 등 시스템 환경에 관한 요구사항
- 비용, 일정 등 프로젝트 계획에 관한 요구사항

## 요구 사항 확인

응용 소프트웨어 개발을 위한 UI 표준 및 지침에 따라

기능 및 비기능 요구사항의 도출을 통해

개발하고자 하는 응용 소프트웨어에 적용될 UI 요구사항을 확인

## UI 품질 요구사항**(ISO/IEC 9126 기반)**

기신사효유이

### 기능성

실제 수행 결과와 품질 요구 사항의 차이를 분석
실제 사용 시 정확치 않은 결과 발생 확률 관련 품질 기준

한마디로 “제대로 기능하는가?”

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 적절성 
(Suitability) | 소프트웨어 제품이 주어진 작업과 사용자의 목표에 필요 & 적절한 기능들을 제공해 줄 수 있는 소프트웨어의 능력 |
| 정밀성 
(Accuracy) | 소프트웨어 제품이 요구되는 정확도로 
올바른 결과를 산출할 수 있는 능력 |
| 상호 운용성 
(Interoperability) | 소프트웨어 제품이 특정 시스템과 
상호 작용하여 운영될 수 있는 능력 |
| 보안성 
(Security) | 비인가된 접근을 차단하고, 
우연 또는 고의적인 접근을 인지하여 대처할 수 있는 능력 |
| 호환성 
(Compliance) | 소프트웨어 제품이 비슷한 환경에서
연관된 표준, 관례 및 규정을 준수하는 능력 |

### 신뢰성

시스템이 일정한 시간 또는 작동되는 시간 동안 의도하는 기능을 수행함을 보증하는 품질

결함 또는 고장 또는 오류 시 회피 회복과 관련된 능력

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 성숙성 
(Maturity) | 소프트웨어 결함으로 인한 고장을 회피할 수 있는 소프트웨어의 능력 |
| 고장 허용성 
(Fault tolerance) | 소프트웨어 결함이나 인터페이스 오류 시에도 
특정 수준 이상의 성능을 유지할 수 있는 능력 |
| 회복성 
(Recoverability) | 소프트웨어 고장 발생 시 영향을 받은 데이터를 복구하고 
성능의 수준을 다시 확보할 수 있는 능력 |

### 사용성

사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준

“얼마나 쓰기 편한가?”

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 이해성 
(Understandability) | 소프트웨어의 논리적인 개념과 적용 가능성을 구분하는 데 필요한 
사용자의 노력 정도에 따른 소프트웨어 특성 |
| 학습성 
(Learnability) | 소프트웨어 애플리케이션 학습에 필요한 
사용자의 노력 정도에 따른 특성 |
| 운용성 
(Operability) | 소프트웨어의 운용과 운용 통제에 필요한 
사용자의 노력 정도에 따른 특성 |

### 효율성

 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 시간 효율성 
(Time Behaviour) | 소프트웨어의 기능을 수행하는 데 있어서 
반응 시간, 처리 시간 및 처리율에 따른 특성 |
| 자원 효율성 
(Resource Behaviour) | 소프트웨어의 기능을 수행하는 데 있어서 사용되는 자원의 양과 그 지속 시간에 따른 특성 |

### 유지보수성

요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 분석성 
(Analyzability) | 고장의 원인이나 결함 진단 또는 수정이 요구되는 부분의 확인에 필요한 
노력 정도에 따른 소프트웨어 특성 |
| 변경성 
(Changeability) | 결함 제거 또는 환경 변화에 따른 수정에 필요한 노력 정도에 따른 특성 |
| 안정성 
(Stability) | 변경으로 발생하는 예상치 못한 영향에 의한 위험 요소에 따른 특성 |
| 시험성 
(Testability) | 소프트웨어 변경되어 검증에 필요한 노력의 정도에 따른 특성 |

### 이식성

다른 플랫폼(운영체제)에서도 많은 추가 작업 없이 얼마나 쉽게 적용이 가능한가에 대한 품질 기준

| **상세 품질 요구사항** | **설명** |
| --- | --- |
| 적용성 
(Adaptability) | 고려된 소프트웨어의 목적을 위해 제공된 수단이나 다른 조치 없이 특정 환경으로 전환되는 능력에 따른 소프트웨어 특성 |
| 설치성 
(Installability) | 특정 환경에 소프트웨어를 설치하는 데 필요한 
노력의 정도에 따른 특성 |
| 대체성 
(Replaceability) | 특정 운용 환경 하에서 동일한 목적 달성을 위해 
다른 소프트웨어를 대신 사용할 수 있는 능력 |

# **UI 표준**

디자인 철학과 원칙 기반 하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면 구성 등에 관한 규약

## 구성

| **UI 표준 구성** | **설명** |
| --- | --- |
| 전체적인 UX 원칙 | 사용자의 관점에서 사용자 업무를 효율적으로 수행할 수 있는 UX 원칙 정의 |
| 정책 및 철학 | 조직의 목표나 정체성을 포함하는 정책 및 철학 설정 |
| UI 스타일 가이드 | UI에 대한 구동 환경 및 레이아웃 등을 정의 |
| UI 패턴 모델 정의 | CRUD 방식을 기반으로 데이터 입력, 출력 패턴 모델 정의 |
| UI 표준 수립을 위한 조직 구성 | UI 팀 및 표준 개발팀을 주축으로 추진 조직 구성 |

## 수립 시 고려 사항

- 사용자가 불편해하지 않아야 한다
- 많은 업무 케이스를 포함해야 한다
- 다양한 사용상황에 대처할 수 있어야 한다
- 표준 적용이 쉽도록 충분한 가이드와 활용 수단 제공이 필요하다
- 변화하는 상황에 맞게 빠르게 변경할 수 있는 관리조직 수반이 필요하다

## 스타일 가이드 구성

- 구동 환경
    
    운영체제 확인
    
    브라우저 확인
    
    모니터 해상도 확인
    
    프레임 세트 확인
    
    cf) 프레임 세트란?
    
    **HTML4에서 사용되던 문서 분할 방식**으로, 하나의 브라우저 창을 여러 영역으로 나누어 각각에 다른 HTML 문서를 동시에 표시하는 구조
    
    | **구분** | **프레임 구분** | **단일 프레임** | **웹 애플리케이션 경우** |
    | --- | --- | --- | --- |
    | **콘텐츠 구성** | - 프레임별 콘텐츠 구성
    - 각 프레임의 페이지에서 메뉴, 배너 구성 등 일괄 적용 | - 하나의 전체 페이지에서 영역별 콘텐츠를 자유롭게 구성 가능
    - 페이지별로 메뉴, 배너 구성, 콘텐츠 변경관리 편리 | - 페이지별 구성 콘텐츠에 구성이 같은 패턴
    - 페이지별로 특화된 배너를 적용하는 경우는 적음 |
    | **디자인** | - 프레임별 이미지 적용
    - 프레임 내에 배경 이미지 적용 | - 배경 이미지 사용 시에 전체 페이지 내에서 스크롤이 생김 | - 업무 처리가 주목적으로 페이지 전체에 이미지 적용하는 경우는 적음 |
    | **속도** | - 변경되는 프레임만 새로 로딩됨(브라우저 속도 향상) | - 페이지 전체가 새로 로딩됨(브라우저 속도 지연) | - 메뉴 변경 시 페이지 로딩이 빨라야 함 |
    | **기타** | - 디자인과 관리에 제약이 있어 현대 웹에서는 거의 사용되지 않음 | - 디자인과 유지보수가 용이
    - 다양한 레이아웃 및 반응형 웹 구현이 가능 | - 사용자 경험(UX)과 업무 효율성 중시
    - SPA(Single Page Application) 구조가 많음 |
- 레이아웃
    
    기본 배치는 크게 상단(Top), 왼쪽(Left), 콘텐츠(Contents) 영역의 3개 부분으로 설계
    
    하단 메뉴 구성(Footer Area)은 상황에 맞게 추가 및 제외
    
    사용 환경에 맞춰서 페이지 폭을 정의
    
    브라우저 사이즈에 따라 페이지 폭 크기를 유동적으로 적용
    
    | **구분** | **설명** |
    | --- | --- |
    | **상단 메뉴 구성** **(Top Area) 정의** | -필수적으로 적용하는 사항
    -구성요소로 시스템 로고, 로그인 사용자, 바로 가기 메뉴(Quick Menu), 주메뉴(Main Navigation) 존재
    -시스템 전체 페이지에 동일하게 적용 |
    | **좌측 메뉴 구성** **(Left Area) 정의** | -선택적으로 적용하는 사항
    -구성요소로 서브 메뉴, 배너 존재
    -시스템별 서브 페이지에 선택 적용함 |
    | **내용 구성** **(Contents Area) 정의** | -필수적으로 적용하는 사항
    -구성요소로 메인 이미지, 시스템별 구성 콘텐츠 존재 |
    | **하단 메뉴 구성** **(Footer Area) 정의** | -선택적으로 적용하는 사항
    -구성요소로는 회사 CI, 저작권등 존재
    -회사 상황에 맞춰 적용 및 삭제 가능 |
    
    cf) 상단메뉴 구성
    
    | **구분** | **설명** |
    | --- | --- |
    | **로고 구역** **(Logo Area)** | - 화면 왼쪽 상단에 위치하며 회사 로고+시스템 로고가 들어감
    - 여백의 사이즈는 일정하게 하고 페이지 별로 크기를 고정하여 
    웹 사이트 전체에 일관성 있게 구현 |
    | **접속자 정보** **(Login User)** | - 화면 우측 상단 첫 번째에 위치
    - 접속자에 대한 정보를 표시 |
    | **바로 가기 메뉴** **(Quick Menu)** | - 로고 우측 상단 두 번째에 위치
    - 홈, 매뉴얼, 사이트 맵, 관리자 등의 메뉴들을 우측 정렬로 배치 |
    | **주 메뉴** **(Main Navigation)** | - 로고 우측 하단에 위치
    - 시스템의 주메뉴를 왼쪽 정렬로 배치
    - 마우스 오버 시 해당 메뉴의 배경 화면색 혹은 글자색이 변경되게 |

## **UI 패턴 모델(Pattern Model)**

CRUD 방식 기반 데이터의 입출력을 처리하는 화면 흐름을 포함하여 오퍼레이션 방식에 대한 표준 절차를 표시하고 UI 패턴 모델을 개발

표준 프레임워크로 개발하고 유스케이스를 이용해서 패턴 별 표준 개발 방법 총 7가지 영역을 정의

**1. 업무 화면 클라이언트 정의**

- 제안 단계에서 결정된 클라이언트를 통해 설계자는 개발 시에 필요한 공통 요소 식별, 디렉토리 구성, 개발 환경 구축 부분 도출
- 클라이언트에 출력되는 UI는 
X-Internet과 같은 리치 클라이언트 도구와
일반 JSP, HTML 기반의 씬 클라이언트방식이 존재

**2. 서버 컨트롤러(Controller) 정의**

- 프레임워크를 도입한다면 해당 프레임워크가 제공하는 방식 채택
- 별도의 클라이언트 제품을 도입하는 경우 서버 컨트롤러와의 연동 방식 결정

**3. 서버 메시지 및 예외 처리 정의**

- 서버의 메시지 및 예외 처리를 클라이언트 UI에 전달하는 방식을 결정
- S(System)
    - 시스템 오류로 인해 발생하는 메시지
    - 런타임 예외를 전달할 때 사용되며, 모든 트랜잭션은 자동으로 복원(Rollback)
- E(Error)
    - 업무 처리 로직의 일환으로 애플리케이션 예외를 전달할 때 사용
    - 모든 트랜잭션은 자동으로 복원
- I(Information)
    - 정상적인 업무 처리 결과나 관련 정보에 대한 확인 메시지를 사용자에게 알려주고자 할 때 사용
    - 이때 모든 트랜잭션은 커밋(Commit) 됨

**4. 클라이언트-서버 간 데이터 변환 정의**

- 어떤 방식의 오브젝트(Object)를 사용할 것인지를 먼저 결정
- 클라이언트와 서버 간의 데이터 형태 변환을 어떻게 처리할 것인지 방안 마련

**5. 기업 포털 연계 정의**

- EP-SSO-사용자 간 연계 방안을 URL 연계 시를 고려하여 정의

**6. 보고서 정의**

- 클라이언트와 리포트 솔루션 간의 연계 방식을 결정

**7. 외부 컴포넌트 연계 정의**

- 외부 UI 컴포넌트를 도입할 때, 서버와의 연계 방식으로 결정

## UI 지침

UI 표준에 따라 사용자 인터페이스 설계, 개발 시 지켜야 할 세부 사항을 규정하는 가이드라인

### 주요 기법

- 3C 분석: 고객 / 자사 / 경쟁사
- SWOT 분석: 강점 / 약점 / 기회 / 위기
- 시나리오 플래닝: 변화를 사전에 예측하고 다양한 시나리오 설계
- 사용성 테스트: 직접 사용하며 미리 작성된 시나리오에 맞추어 과제 수행 후 질문에 답함
- 워크숍: 소집단 정도의 인원으로 새로운 문제나 과제에 대한 여러 생각들 교환 및 검토

## 스토리 보드

UI 화면 설계를 위해 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임, 기능에 대한 정의, 데이터베이스의 연동 등 구축하는 서비스를 위한 대부분의 정보가 수록된 문서

디자이너과 개발자가 최종적으로 참고하는 산출 문서

- 와이어프레임: 화면단위의 레이아웃
- 스토리 보드: 서비스를 위한 대부분의 정보가 수록된 문서
- 프로토타입: 정적 화면으로 설계된 와이어 프레임 또는 스토리 보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션할 수 있는 모형

# **UI 설계를 위한 UML**

## UML

**Unified Modeling Language**의 약자

객체 지향 소프트웨어 개발 과정에서 산출물을 명세화/시각화/문서화할 때 사용되는

모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어

### 특징

**가시화 언어**

- 개념 모델 작성 시 오류가 적고 의사소통이 용이

**구축 언어**

- 다양한 프로그래밍 언어로 실행 시스템의 예측 가능
- UML을 소스 코드로 변환하여 구축 가능, 역 변환하여 역공학 가능

**명세화 언어**

- 정확한 모델 제시, 완전한 모델 작성 가능

**문서화 언어**

- 시스템에 대한 평가 및 의사소통의 문서

### 구성요소

**사물(Things)**

- 추상적인 개념으로, 주제를 나타내는 요소
- 단어 관점에서 '명사' 또는 '동사'를 의미

**관계(Relationships)**

- 사물의 의미를 확장하고 명확히 하는 요소
- 사물과 사물을 연결하여 관계를 표현하는 요소
- 단어 관점에서 '형용사' 또는 '부사'를 의미

**다이어그램(Diagrams)**

- 사물과 관계를 모아 그림으로 표현한 형태
- 형식과 목적에 따라 9가지로 정의

## UML 다이어그램

### **구조적 다이어그램(Structural Diagram) / 정적 다이어그램(Static Diagram)**

- **클래스(Class)**
    - 클래스 다이어그램은 객체 지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
- **객체(Object)**
    - 객체 다이어그램은 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현한 다이어그램
    - 연관된 모든 인스턴스를 표현
- **컴포넌트(Component)**
    - 컴포넌트 다이어그램은 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램
- **배치(Deployment)**
    - 배치 다이어그램은 컴포넌트 사이의 종속성을 표현하고, 결과물, 프로세스, 컴포넌트 등 물리적인 요소들의 위치를 표현하는 다이어그램
- **복합체 구조(Composite Structure)**
    - 복합체 구조 다이어그램은 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현하는 다이어그램
- **패키지(Package)**
    - 패키지 다이어그램은 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한 다이어그램

### **행위적 다이어그램(Behavioral Diagram, 동적 다이어그램(Dynamic Diagram)**

- **유스케이스(Usecase)**
    - 유스케이스 다이어그램은 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
- **시퀀스(Sequence)**
    - 시퀀스 다이어그램은 객체 간 동적 상호 작용을 시간적 개념을 중심으로 메시지 흐름으로 표현한 다이어그램
- **커뮤니케이션(Communication)**
    - 커뮤니케이션 다이어그램은 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램
- **상태(State)**
    - 상태 다이어그램은 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
- **활동(Activity)**
    - 활동 다이어그램은 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램
- **타이밍(Timing)**
    - 타이밍 다이어그램은 객체 상태 변화와 시간 제약을 명시적으로 표현하는 다이어그램

## UML 확장 모델의 스테레오 타입

UML의 기본적 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘

형태는 기존의 UML의 요소를 그대로 사용하지만 내부 의미는 다른 목적으로 사용하도록 확장

' ≪≫ ' (길러멧; Guillemet) 기호를 사용하여 표현

- ≪include≫ : 하나의 유스케이스가 어떤 시점에 반드시 다른 유스케이스를 실행하는 포함 관계
- ≪extend≫ : 하나의 유스케이스가 어떤 시점에 다른 유스케이스를 실행할 수도 있고, 그렇지 않을 수도 있는 확장 관계
- ≪interface≫ : 모든 메서드가 추상 메서드이며 바로 인스턴스를 만들 수 없는 클래스로 추상 메소드와 상수만으로 구성된 클래스
- ≪entity≫ : 일반적으로 정보 또는 오래 지속되는 연관된 행위를 형상화하는 클래스로 유스케이스 처리 흐름이 수행되는 과정에서 기억 장치에 저장되어야 할 정보를 표현하는 클래스
- ≪boundary≫ : 시스템과 외부 액터와의 상호 작용을 담당하는 클래스
- ≪control≫ : 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스

## **UML의 유형**

### **클래스 다이어그램**

### 클래스

- 공통의 속성 / 연산 / 관계 / 의미를 공유하는 객체들의 집합

### 속성

- 클래스의 구조적 특성에 이름을 붙인 것으로 특성에 해당하는 인스턴스가 보유할 수 있는 값의 범위를 기술

### 연산(메서드)

- 이름, 타입, 매개변수들과 연관된 행위를 호출하는데 요구되는 제약사항들을 명시하는 
클래스의 행위적 특징
- 객체에 요청하여 행동에 영향을 줄 수 있는 서비스

### **접근 제어자**

클래스에 접근할 수 있는 정도를 표현

- - : 클래스 내부 접근만 허용(private)
- + : 클래스 외부 접근을 허용(public)
- # : 동일 패키지/파생 클래스에서 접근 가능(protected)
- ~ : 동일 패키지 클래스에서 접근 가능(default)

### 관계

- **연관**
    - 연관 관계는 클래스가 서로 개념적으로 연결된 선(——)
    - 연관 관계는 2개 이상의 사물이 서로 관련되어 있는 상태를 표현
    - 사물 사이를 실선으로 연결하여 표현하며, 방향성은 화살표로 표현
    - 서로에게 영향을 주는 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결
- **의존**
    - 하나의 클래스가 또 다른 클래스를 사용하는 관계
    - 다른 클래스의 멤버 함수 사용
    - 의존 관계는 사물 사이에 서로 연관은 있으나 필요에 따라 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현
    - 하나의 클래스에 있는 멤버 함수의 인자가 변함에 따라 다른 클래스에 영향을 미칠 때의 관계
    - 영향을 주는 사물이 영향을 받는 사물 쪽으로 점선 화살표를 연결하여 표현
- **일반화**
    - 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
    - 일반적인 개념을 부모(상위)라고 하고, 구체적인 개념을 자식(하위)이라 함
    - 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현
    - 일반화 관계는 다른 의미로 상속 관계라고 함
- **실체화**
    - 추상 클래스나 인터페이스를 상속받아 자식클래스가 추상 메소드를 구현할 때 사용
    - 사물이 할 수 있거나, 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화할 수 있는 관계를 표현
- **포함**
    - 영구적이고, 집합 관계보다 더 강한 관계로 구성
    - 포함되는 쪽(Part; 부분)에서 포함하는 쪽(Whole; 전체)으로 속이 채워진 마름모를 연결하여 표현
    - 포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현
    - 포함 관계는 복합 관계라고도 함
- **집합**
    - 하나의 객체에 여러 개의 독립적인 객체들이 구성되는 관계
    - 집합 관계는 하나의 사물이 다른 사물에 포함되어 있는 관계 표현
    - 포함되는 쪽(Part; 부분)에서 포함하는 쪽(Whole; 전체)으로 속이 빈 마름모를 연결하여 표현

### **유스케이스 다이어그램**

시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 **사용자의 관점에서 표현**하는 다이어그램

![유스케이스 다이어그램.png](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%8B%E1%85%B2%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png)

**유스케이스(Usecase)**

- 시스템이 제공해야 하는 서비스, 기능
- 액터가 시스템을 통해 수행하는 일련의 행위

**액터(Actor)**

- 사용자가 시스템에 대해 수행하는 역할
- 시스템과 상호 작용하는 사람 또는 사물
- 이벤트 흐름을 시작하게 하는 객체

**시스템(System)**

- 전체 시스템의 영역을 표현

**시나리오**

- 발생되는 이벤트의 흐름

**이벤트의 흐름**

- 사람, 시스템, 하드웨어, 시간의 흐름에 의해 시작

### 관계 of **유스케이스 다이어그램**

액터와 유스케이스, 유스케이스와 유스케이스 사이에 나타남

- **포함**
    - 유스케이스를 수행할 때 다른 유스케이스가 반드시 수행되는 관계
    - 유스케이스 다이어그램에서는 다른 유스케이스가 나타내는 이벤트 흐름을 포함(Include)하는 관계를 유스케이스 간에 표현
    - 여러 유스케이스에서 공통적으로 발견되는 기능 표현
    - 2개 이상의 유스케이스 이벤트 흐름에서 중복적인 부분이 발생하는 경우 유스케이스 간 포함 관계를 설정하여 해결
    - ≪include≫로 표현
- **확장**
    - 확장 관계의 유스케이스는 포함 관계처럼 여러 유스케이스에 걸쳐 중복적으로 사용되지 않고, 특정 조건에서 한 유스케이스로만 확장되는 관계
    - 확장 유스케이스는 특정 조건이 만족되는 상황에서만 확장 유스케이스의 이벤트 흐름이 수행
    - 한 유스케이스에서 추가되거나 확장된 기능 표현
    - ≪extend≫로 표현
- **일반화**
    - 추상적인 액터와 좀 더 구체적인 액터 사이에 맺어주는 관계
    - 일반화 관계를 액터에 적용하면 유스케이스 다이어그램에서 사용되는 여러 액터들의 의미를 좀 더 명확하게 하고 다이어그램도 보다 간결하게 작성
    - 하위 액터나 유스케이스에서 상위 액터, 유스케이스 쪽으로 속이 빈 삼각형 화살표를 실선으로 연결

### **시퀀스 다이어그램**

- 시퀀스 다이어그램은 객체 간 상호 작용을 메시지 흐름으로 표현한 다이어그램
- 객체 간의 동적 상호 작용을 시간적 개념을 중심으로 모델링하는 과정
- 시퀀스 다이어그램에서는 객체의 오퍼레이션과 속성을 상세히 정의해야 함
- 시퀀스 다이어그램은 유스케이스를 실현(Realization)

![시퀀스 다이어그램.png](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png)

### 구성요소

**객체(Object)**

- 객체는 위쪽에 표시되며 아래로 생명선을 가짐
- 객체는 사각형 안에 밑줄 친 이름으로 명시

**생명선(Lifeline)**

- 객체로부터 뻗어 나가는 점선
- 실제 시간이 흐름에 따라 객체의 생명주기 동안 발생하는 이벤트를 명시

**실행(Activation)**

- 직사각형은 오퍼레이션(함수)이 실행되는 시간을 의미
- 직사각형이 길어질수록 오퍼레이션 수행시간이 긺

**메시지(Message)**

- 객체 간의 상호 작용은 메시지 교환으로 이루어짐
- 한 객체에서 다른 객체로의 메시지를 전달하여 전달받은 객체의 오퍼레이션을 수행

### **패키지 다이어그램**

시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램

![패키지 다이어그램.png](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%91%E1%85%A2%E1%84%8F%E1%85%B5%E1%84%8C%E1%85%B5_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png)

### 구성요소

**패키지**

- 요소들을 그룹으로 조직하기 위한 요소

**의존관계**

- 하나의 패키지가 다른 패키지를 사용하는 관계
- 의존성의 성질을 나타내기 위해 스테레오 타입을 붙일 수 있음
- 스테레오 타입에는 ≪import≫, ≪access≫가 있음

### **활동 다이어그램**

시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램

오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현

하나의 유스케이스 안이나, 유스케이스 사이에서 발생하는 복잡한 처리의 흐름을 명확하게 표현

![활동 다이어그램.png](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%92%E1%85%AA%E1%86%AF%E1%84%83%E1%85%A9%E1%86%BC_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png)

### 구성요소

**시작점(Initial Node)**

- 활동의 시작(액션이나 액티비티 시작)을 의미
- 하나의 다이어그램 안에는 하나의 시작점만 존재
- 검은색 동그라미로 표현

**전이(Transition)**

- 실행의 흐름을 나타냄
- 화살표로 표현

**액션(Action) / 액티비티(Activity)**

- 어떠한 일들의 처리와 실행을 의미
- 액션(Action)은 더 이상 분해할 수 없는 단일 작업이고, 액티비티(Activity)는 몇 개의 액션으로 분리될 수 있는 작업
- 모서리가 둥근 사각형으로 표현하고, 둥근 사각형 안에 액션이나 액티비티 명칭 기술

**종료점(Final Node)**

- 처리의 종료를 의미
- 하나의 다이어그램 안에는 여러 개의 종료 노드가 있을 수 있음
- 검은색 동그라미를 포함한 원으로 표현

**조건(판단) 노드(Decision Node)**

- 조건에 따른 제어 흐름의 분리를 표현
- 마름모로 표현하고 들어오는 제어 흐름은 한 개이고, 나가는 제어 흐름은 여러 개로 표현

**병합 노드(Merge Node)**

- 여러 경로의 흐름이 하나로 합쳐진 것을 표현
- 마름모로 표현하고 들어오는 제어 흐름은 여러 개이고, 나가는 제어 흐름은 한 개로 표현

**포크 노드(Fork Node)**

- 평행적으로 수행되는 흐름을 나누는 노드
- 굵은 가로선으로 표현하고 들어오는 액티비티 흐름은 한 개이고, 나가는 액티비티 흐름은 여러 개

**조인 노드(Join Node)**

- Fork Node로 나눠진 흐름을 다시 하나로 합치는 노드
- 굵은 가로선으로 표현하고 들어오는 액티비티 흐름은 여러 개이고, 나가는 액티비티 흐름은 한 개

**구획면(Swim Lane)**

- 액티비티 수행을 담당하는 주체를 구분하는 면
- 가로 또는 세로 실선을 그어 구분

### **상태 다이어그램**

하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램

어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호 작용하는 과정에서의 상태 변화를 표현

객체는 파악된 상태들 이외의 상태는 가질 수 없고, 특정 순간에는 오직 한 상태로만 존재할 수 있음

객체의 상태 == 객체가 갖는 속성값의 변화

### 구성요소

**상태(State)**

- 객체가 존재할 수 있는 조건 중의 하나
- 둥근 사각형 안에 객체의 상태 기술

**시작 상태**

- 객체의 시작 상태
- 속이 채워진 원으로 표현

**종료 상태**

- 객체의 종료 상태
- 원 안에 속이 채워진 원으로 표현

**전이**

- 객체의 상태가 다른 상태로 변경되는 상태
- 상태의 사이의 흐름, 변화
- 화살표로 표현

**이벤트(Event)**

- 객체의 전이를 유발하는 자극
- 상태의 변화를 주는 현상
- 상태의 전이를 유발하는 이벤트는 전이 위에 이벤트 이름 표시
- 이벤트: 시간의 흐름, 조건, 외부 신호 등

**전이 조건**

- 특정 조건 만족 시 전이 발생하도록 하기 위해 사용되는 속성값의 boolean 식

### **커뮤니케이션 다이어그램**

시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 
메시지뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램

시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 표현한 다이어그램

![커뮤니케이션 다이어그램.png](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B2%E1%84%82%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png)

### 구성요소

**액터(Actor)**

- 시스템으로부터 서비스를 요청하는 외부 요소(사람, 외부시스템)

**객체(Object)**

- 메시지를 주고받은 주체
- 콜론(:)을 기준으로 앞쪽에는 객체명, 뒤쪽에는 클래스명 기술

**링크(Link)**

- 객체들 간의 관계를 표현
- 클래스가 아닌 실제 객체와의 관계를 직접적으로 보여주는 객체들 사이의 링크
- 액터와 객체, 객체 간 실선으로 표현
- 링크에 메시지를 표현

**메시지(Message)**

- 객체가 상호 작용을 위해 주고받는 메시지
- 메시지는 상대 객체별로 여러 개의 정의가 이루어지므로, 하나의 동일한 링크에서 여러 개의 메시지가 전달
- 화살표의 방향은 메시지를 받는 쪽으로 향하게 표현

### **컴포넌트 다이어그램**

시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램

코드 컴포넌트 기반의 물리적 구조로 표현

실질적 프로그래밍 작업에 사용

![컴포넌트 다이어그램.jpeg](%E2%9C%85%206%20%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8(UI%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8,%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%20222e41ef93d28070bff5d94346586bfe/%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%A9%E1%84%82%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.jpeg)

### 구성요소

**컴포넌트**

- 컴포넌트는 탭이 달린 직사각형으로 표현
- 모든 컴포넌트는 반드시 이름을 가지고 있어야 함
- 컴포넌트가 패키지에 포함되어 있다면 컴포넌트의 이름 앞에 패키지 이름을 붙일 수 있으며, 클래스처럼 컴포넌트에 꼬리표 값을 달아주거나 컴포넌트 내부의 오퍼레이션을 보여줄 수도 있음

**인터페이스**

- 인터페이스를 실체화한다는 의미는 실제로 동작하는 컴포넌트에 인터페이스를 적용한다는 뜻
- 컴포넌트와 인터페이스는 화살표 모양의 점선(의존 관계)으로 연결

**의존 관계**

- 컴포넌트 사이의 의존하는 관계 표현
- 컴포넌트 사이의 의존 관계는 한 컴포넌트에 변경이 발생한 경우, 변경 범위 추적에 유용