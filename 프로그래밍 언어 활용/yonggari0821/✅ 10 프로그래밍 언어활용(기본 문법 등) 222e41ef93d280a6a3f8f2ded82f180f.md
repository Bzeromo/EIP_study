# ✅ 10. 프로그래밍 언어활용(기본 문법 등)

# 프로그래밍 언어 유형 분류

## 개발 편의성에 따른 분류

### 저급 언어

기계가 이해할 수 있도록 만들어진 언어

ex) 기계어, 어셈블리어

### 고급 언어

개발자가 소스 코드를 작성할 때 쉽게 이해할 수 있도록 인간에게 편하게 작성된 언어

ex) C, C++, Java, Python

## 실행 방식에 따른 분류

### 명령형 언어

컴퓨터에 저장된 명령어들이 순차적으로 실행되는 프로그래밍 방식

== 절차형 언어

ex) FORTRAN, COBOL, PASCAL, C

### 객체 지향 언어

객체 간의 메시지 통신을 이용하여 프로그래밍 하는 방식

ex) Java, C++

### 함수형 언어

수학적 수식과 같은 함수들로 프로그램을 구성하여 호출하는 방식

ex) LISP

### 논리형 언어

논리 문장을 이용하여 프로그램을 표현하고 계산을 수행하는 개념에 기반한 프로그래밍

ex) 프롤로그

## 구현 기법에 따른 분류

### 컴파일

고급언어 ⇒ 기계어로 번역

컴파일러가 실행에 필요한 정보 미리 계산하여 실행파일 만듦 ⇒ 실행 속도 높음

ex) FORTRAN, PASCAL, C, C++

### 인터프리터

고급언어 명령문을 하나씩 번역하고 실행

프로그램 실행과 동시에 동작

ex) BASIC, 프롤로그, LISP, Python

### 하이브리드(혼합)

고급 언어를 컴파일 하여 중간 언어로 번역 후, 인터프리터에 의해 번역을 실행하는 방식의 언어

ex) Java

- Java 매커니즘
    1. **소스 코드 작성**
        - 사람이 읽을 수 있는 고급 언어(Java 등)로 코드를 작성합니다.
    2. **컴파일 단계**
        - 작성한 소스 코드를 **컴파일러**가 읽어서, 바로 기계어(실행 파일)로 바꾸지 않고, **중간 언어(바이트코드)**로 변환합니다.
        - Java의 경우 **`.java`** 파일이 **바이트코드**인 **`.class`** 파일로 바뀝니다.
    3. **실행(인터프리터 단계)**
        - 이 중간 언어(바이트코드)는 바로 실행되지 않고, **JVM(Java Virtual Machine)**이라는 가상 머신이 읽어서 한 줄씩 해석(인터프리트)하며 실행합니다.
        - 즉, 바이트코드를 실제 컴퓨터가 이해할 수 있는 기계어로 바꿔서 실행합니다.

# 프로그래밍 언어별 특성

## 절차적(명령형) 프로그래밍 언어

- 알골(ALGOL)
    - 알고리즘의 연구개발에 이용하기 위한 목적으로 생성
    - 절차형 언어로는 최초로 재귀 호출이 가능
    - 이후 언어의 발전에 큰 영향을 미침
- C 언어
    - 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어
    - 모든 컴퓨터 시스템에서 사용할 수 있도록 설계된 프로그래밍 언어
- 베이직(BASIC)
    - 교육용으로 개발되어 언어의 문법이 쉬움
    - 다양한 종류의 베이직이 존재
    - 서로 다른 종류 사이의 소스 코드는 호환되지 않음
- 포트란(PORTRAN)
    - 과학계산에서 필수적인 벡터, 행렬 계산 기능 등이 내장된 과학 기술 전문 언어
    - 산술 기호, 삼각함수, 지수함수, 대수 함수 등과 같은 수학 함수들 사용 가능

## 객체 지향 프로그래밍 언어

- C++
    - C++는 C 문법에 객체 지향 프로그래밍 개념과 일반화 프로그래밍을 위한 템플릿 기능이 추가
    - C++ 개발자는 원하는 많은 작업을 성능 하락이 없는 형태로 개발이 가능
    - 직접 신경 써야 하는 것들(메모리 관리)이 많은 언어이기 때문에 개발이 어려움
- C#
    - 마이크로소프트에서 개발한 객체 지향 프로그래밍 언어
    - C++과 자바의 문법과 비슷한 문법을 가지고 있음
    - C#은 자바와 달리 불안전 코드(Unsafe Code)와 같은 기술을 통하여 플랫폼 간 상호 운용성 확보
- 자바(JAVA)
    - 자바는 썬 마이크로 시스템즈(Oracle 합병됨)가 개발한 객체 지향적 프로그래밍 언어
    - 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어
    - 자바 컴파일러는 자바 언어로 작성된 프로그램을 바이트 코드라는 특수한 바이너리 형태로 변환
- 델파이(Delphi)
    - 기본적인 문법은 파스칼 문법에 여러 기능이 추가되어 존재
    - 델파이는 윈도즈(Windows) 아래에서 모든 부분을 프로그래밍할 수 있는 언어
    - 높은 생산성과 간결한 코드가 대표적인 장점이고, C++와 비슷한 수준의 저수준 시스템 프로그래밍도 가능

## 스크립트 언어

- PHP
    - 동적 웹 페이지를 만들기 위해 설계됨
    - PHP로 작성된 코드를 HTML에 입력 시 웹 서버에서 해당 코드를 인식하여 작성자가 원하는 웹 페이지를 생성
    - 인터페이스 방식의 자체 인터프리터를 제공
- 펄(Perl)
    - 인터프리터 방식의 프로그래밍 언어
    - 실용성을 모토로 하고 있어 C, 쉘 스크립트 (sh) 등 다른 프로그래밍 언어에서 뛰어난 기능을 많이 도입
    - 불특젖ㅇ한 데이터 길이의 제약 없이 강력한 문자열 처리 기능을 제공
- 파이썬(Python)
    - 다양한 플랫폼에서 쓸 수 있고, 라이브러리(모듈)가 풍부
    - 유니코드 문자열을 지원하여 다양한 언어의 문자 처리
    - 들여쓰기를 사용하여 블록을 구분하는 문법 채용
    - 다른 언어로 쓰인 모듈들을 연결하는 언어
- 자바스크립트(Javascript)
    - 객체 기반의 스크립트 프로그래밍 언어
    - 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능이 존재
    - 자바스크립트는 브라우저마다 지원되는 버전이 상이

## 선언형 언어

### 함수형 언어

- 하스켈(Haskell)
    - 패턴 맞춤, 커링, 조건제시법, 가드, 연산자 정의 등의 기능이 존재
    - 재귀 함수나 대수적 자료형도 지원
- 리스프(LISP)
    - 수학 표기법을 나타내기 위한 목적으로 생성
    - 트리 자료구조, 가비지 컬렉션, 동적 자료형과 인터프리터와 같은 개념 제시
    - 함수 호출 시 함수 이름 혹은 연산자가 첫 번째로 위치하여 피연산자가 이어 위치

### 논리형 언어

- 프롤로그(Prolog)
    - 논리식을 기반으로 객체 간의 관계에 관한 문제를 해결하기 위해 사용
    - 인공지능이나 계산 언어학 분야, 자연언어 처리 분야에서 사용

### 특수 분야 언어

- SQL
    - 관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
    - 데이터베이스 관련 프로그램들이 SQL을 표준으로 채택

# 객체 지향 프로그래밍

- 클래스(Class)
    - 객체 지향 프로그래밍에서 객체를 표현하는 추상 데이터 타입으로 객체를 생성하는 틀
    - 클래스를 통해 추상화된 자료형을 제공
- 객체(Object)
    - 개체, 속성, 메서드로 구성된 클래스의 인스턴스를 의미
    - 개체(Entity): 현실 세계에 보이는 본질을 의미
    - 속성(Attribute): 자료 저장소 역할을 하며, 절차 지향 프로그래밍의 변수와 대응
    - 메서드(Method): 호출 단위를 의미하며, 절차 지향 프로그래밍의 함수와 대응
- 메시지(Message)
    - 객체 간의 통신

# 기본 문법 활용하기

JAVA 숙련자 기준 기본적인 건 제외하고 정리

### boolean

- C 언어에는 boolean 타입이 없다
- Python에는 True/False가 대문자로 시작한다
- C++에서는 boolean이 아니라 bool이다.

### String

- C 언어에는 String타입이 없고 char[]이다.
- C++에서는 String이 아니라 string으로 소문자로 시작한다.

### float vs double

둘 다 부동 소수점 실수값

but 

float는 4바이트로 소수점 6번째 자리까지 표현

double은 8바이트로 소수점 15번째 자리까지 표현

### 포인터

포인터는 변수의 주소값을 저장하는 공간

```c
int a = 10;
int* b = &a;
printf("%d %d", a, *b); // 10, 10
```

- 심화
    - 문제1
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        int main(int argc, char *argv[]) {
            int arr[2][3] = {1, 2, 3, 4, 5, 6};
            int (*p)[3] = NULL;
            p = arr;
        
            printf("%d, ", *(p[0] + 1) + *(p[1] + 2));
            printf("%d", *(*(p + 1) + 0) + *(*(p + 1) + 1));
        
            return 0;
        }
        ```
        
        우선
        
        ```c
        arr[0][0] = 1;
        arr[0][1] = 2;
        arr[0][2] = 3;
        arr[1][0] = 4;
        arr[1][1] = 5;
        arr[1][2] = 6;
        
        1 2 3
        4 5 6
        ```
        
        인 상태임.
        
        그리고,
        
        ```c
        int (*p)[3] = NULL;
        ```
        
        에서
        
        p는 int 3개짜리 배열을 가리키는 포인터임.
        
        기본 개념 예시에서
        
        ```c
        int a = 10;
        int* b = &a;
        printf("%d %d", a, *b);
        ```
        
        int *b가 a의 주소값을 가리키고
        
        b는 a의 주소값을 가리키는 포인터임을 생각한다면
        
        int (*p)[3]이 왜 int[3]을 가리키는 포인터인지 알 수 있음!
        
        Q) 괄호는 왜 씌워요?
        
        괄호를 안씌우면 int[3]을 가리키는 포인터 p가 아니라
        
        3개의 int를 가리키는 포인터들의 배열 p가 됨.
        
        **1) int (*p);**
        
        ```c
        int arr[2][3];
        int (*p)[3] = arr; // arr의 행(3개짜리 int 배열)을 가리킴
        ```
        
        **2) int *p;**
        
        ```c
        int a = 10, b = 20, c = 30;
        int *p[3] = {&a, &b, &c}; // int를 가리키는 포인터 3개짜리 배열
        ```
        
        그래서 지금
        
        int[3]을 가리키는 포인터 p가 NULL로 초기화 되어 있는 상태임.
        
        이제 이 p를 arr의 주소를 가리키게 해둠.
        
        ```c
        p = arr;
        ```
        
        배열의 주소 == 배열의 첫칸의 주소
        
        이므로,
        
        arr[0][0]에 위치한다고 보면 됨.
        
        그럼 이제
        
        ```c
        printf("%d, ", *(p[0] + 1) + *(p[1] + 2));
        ```
        
        여기서 
        
        p[0]은 arr[0]
        
        즉 1,2,3을
        
        나아가 그 중에서도 첫 번째인 1을
        
        p[1]은 arr[1]
        
        즉 4,5,6을
        
        나아가 그 중에서도 첫 번째인 4를
        
        가리킨다고 보면 됨.
        
        그리고
        
        각각 1과 2씩 더했으므로
        
        1(0), 2(1), 3(2) 중 2
        
        4(0), 5(1), 6(2) 중 6
        
        을 골라 그 합인 8을 출력하면 되는 것임.
        
        ---
        
        두 번째 출력문을 살펴보면,
        
        ```c
        printf("%d", *(*(p + 1) + 0) + *(*(p + 1) + 1));
        ```
        
        여기서
        
        ```c
        *(*(p + 1) + 0)
        ```
        
        는
        
        p + 1 == &arr[0] + 1 == &arr[1]
        
        *(p + 1) == (&arr[0] + 1) == arr[1]
        
        여기서 arr[1]은 int[3]의 배열이므로, 특정 값이 아니라 여전히 주소값이라고 볼 수 있음
        
        그래서 아래에서 + 0 했을 때 여전히 0번째 열의 ‘값’이 아니라 ‘주소’임
        
        *(p + 1) + 0 == (&arr[0] + 1) + 0 == arr[1] + 0 == &arr[1][0]
        
        그래서 여기서 괄호로 묶고 한 번더 * 를 붙혀줘야 값이 되는 것!
        
        *(*(p + 1) + 0) == arr[1][0] == 4
        
        같은 매커니즘으로 뒤의 값은 5이므로 더해서 9 출력!
        

### Python 자료형

<시퀀스>

| **타입** | **변경 가능성** | **순서** | **인덱싱** | **중복 허용** | **생성 방법** |
| --- | --- | --- | --- | --- | --- |
| list | O | O | O | O | **`[1, "apple", 3.14]`** |
| tuple | X | O | O | O | **`(1, "apple", 3.14, True, [10, 20], (5, 6))`** |
| range | X | O | O | O | **`range(5)` - 0~4의 정수** |

<매핑>

| **타입** | **변경 가능성** | **순서** | **인덱싱** | **키-값 쌍** | **중복 허용** | **생성 방법** |
| --- | --- | --- | --- | --- | --- | --- |
| dict | O | O | X | O | 키X/값O | **`{"a": 1, "b": 2}`** |
| set | O | X | X | X | X | **`{1, 2, 3}`** |

### Python 리스트 슬라이싱

```c
리스트[start:end:step]
```

- **start:** 슬라이싱을 시작할 인덱스 (포함)
- **end:** 슬라이싱을 끝낼 인덱스 (불포함, 즉 end 바로 전까지)
- **step:** (선택) 요소를 가져올 간격, 기본값은 1

```c
a = [10, 20, 30, 40, 50, 60, 70]

print(a[1:4])    # [20, 30, 40] (1번 인덱스부터 3번 인덱스까지)
print(a[:3])     # [10, 20, 30] (처음부터 2번 인덱스까지)
print(a[3:])     # [40, 50, 60, 70] (3번 인덱스부터 끝까지)
print(a[::2])    # [10, 30, 50, 70] (처음부터 끝까지 2칸씩 건너뜀)

print(a[::-1])   # [70, 60, 50, 40, 30, 20, 10] (역순)
```

### 식별자 표기법

| **표기법** | **예시** | **특징 및 사용처** |
| --- | --- | --- |
| **카멜케이스**

camelCase | **`myVariableName`** | 첫 단어는 소문자, 이후 단어 첫 글자 대문자. 변수, 함수명 등 |
| **파스칼케이스**

PascalCase | **`MyVariableName`** | 모든 단어의 첫 글자 대문자. 클래스, 타입명 등 |
| **스네이크케이스**

snake_case | **`my_variable_name`** | 모든 글자 소문자, 단어 사이에 언더스코어(**`_`**). 파이썬 변수, 상수 등 |
| **케밥케이스**

kebab-case | **`my-variable-name`** | 모든 글자 소문자, 단어 사이에 하이픈(**`-`**). 주로 URL, CSS 등 |

# C언어 표준 함수

## `printf(포맷 스트링, 변수명);`

### 포맷 스트링 종류

%c: 문자

%s: 문자열

%d: 10진수

%x: 16진수

%o: 8진수

%f: 실수

%[전체 자릿 수].[소숫점 자릿수]: 실수

- 예시 코드
    
    ```c
    #include <stdio.h>
    
    int main() {
        char ch = 'A';
        char str[] = "Hello";
        int num = 255;
        float fnum = 3.14159;
    
        printf("문자 출력: %c\n", ch);              // 문자 출력: A
        printf("문자 'A'를 숫자로 출력: %d\n", ch); // 문자 'A'를 숫자로 출력: 65
        printf("문자열 출력: %s\n", str);           // 문자열 출력: Hello
        printf("10진수 출력: %d\n", num);           // 10진수 출력: 255
        printf("16진수 출력: %x\n", num);           // 16진수 출력: ff
        printf("16진수(대문자): %X\n", num);        // 16진수(대문자): FF
        printf("8진수 출력: %o\n", num);            // 8진수 출력: 377
    
        printf("실수 출력: %f\n", fnum);            // 실수 출력: 3.141590
        printf("실수 출력 (8.3): %8.3f\n", fnum);   // 실수 출력 (8.3):    3.142
        printf("실수 출력 (10.1): %10.1f\n", fnum); // 실수 출력 (10.1):        3.1
    
        printf("숫자 65를 문자로 출력: %c\n", 65);  // 숫자 65를 문자로 출력: A
    
        return 0;
    }
    
    ```
    

# C++ 표준 함수

## `std::cout << 문자열;` (출력)

- iostream 헤더를 선언해야 사용가능함
- `using namespace std;` 를 선언시 `std::` 생략 가능!

## `std::endl;` (개행)

- iostream 헤더를 선언해야 사용가능함
- `using namespace std;` 를 선언시 `std::` 생략 가능!

```cpp
#include <iostream>
using namespace std;

void main() {
	cout << "Hello World"; // Hello World
	cout << "Hello" << endl << "World"; 
	// Hello
	// World
}
```

### 포맷 스트링 종류

%c: 문자

%s: 문자열

%d: 10진수

%x: 16진수

%o: 8진수

%f: 실수

%[전체 자릿 수].[소숫점 자릿수]: 실수

- 예시 코드
    
    ```c
    #include <stdio.h>
    
    int main() {
        char ch = 'A';
        char str[] = "Hello";
        int num = 255;
        float fnum = 3.14159;
    
        printf("문자 출력: %c\n", ch);              // 문자 출력: A
        printf("문자 'A'를 숫자로 출력: %d\n", ch); // 문자 'A'를 숫자로 출력: 65
        printf("문자열 출력: %s\n", str);           // 문자열 출력: Hello
        printf("10진수 출력: %d\n", num);           // 10진수 출력: 255
        printf("16진수 출력: %x\n", num);           // 16진수 출력: ff
        printf("16진수(대문자): %X\n", num);        // 16진수(대문자): FF
        printf("8진수 출력: %o\n", num);            // 8진수 출력: 377
    
        printf("실수 출력: %f\n", fnum);            // 실수 출력: 3.141590
        printf("실수 출력 (8.3): %8.3f\n", fnum);   // 실수 출력 (8.3):    3.142
        printf("실수 출력 (10.1): %10.1f\n", fnum); // 실수 출력 (10.1):        3.1
    
        printf("숫자 65를 문자로 출력: %c\n", 65);  // 숫자 65를 문자로 출력: A
    
        return 0;
    }
    
    ```
    

# python 표준 함수

## print(문자열)

- 출력 후 개행

## print(문자열, end=’’)

- 출력 후 개행 ❌

### 포맷 스트링 종류

%c: 문자

%s: 문자열

%d: 10진수

%x: 16진수

%o: 8진수

%f: 실수

%[전체 자릿 수].[소숫점 자릿수]: 실수

- 예시 코드
    
    ```c
    #include <stdio.h>
    
    int main() {
        char ch = 'A';
        char str[] = "Hello";
        int num = 255;
        float fnum = 3.14159;
    
        printf("문자 출력: %c\n", ch);              // 문자 출력: A
        printf("문자 'A'를 숫자로 출력: %d\n", ch); // 문자 'A'를 숫자로 출력: 65
        printf("문자열 출력: %s\n", str);           // 문자열 출력: Hello
        printf("10진수 출력: %d\n", num);           // 10진수 출력: 255
        printf("16진수 출력: %x\n", num);           // 16진수 출력: ff
        printf("16진수(대문자): %X\n", num);        // 16진수(대문자): FF
        printf("8진수 출력: %o\n", num);            // 8진수 출력: 377
    
        printf("실수 출력: %f\n", fnum);            // 실수 출력: 3.141590
        printf("실수 출력 (8.3): %8.3f\n", fnum);   // 실수 출력 (8.3):    3.142
        printf("실수 출력 (10.1): %10.1f\n", fnum); // 실수 출력 (10.1):        3.1
    
        printf("숫자 65를 문자로 출력: %c\n", 65);  // 숫자 65를 문자로 출력: A
    
        return 0;
    }
    
    ```