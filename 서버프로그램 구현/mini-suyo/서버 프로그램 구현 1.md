# 서버 프로그램 구현 1 정리

## 1. 모듈화 (Modularity)

- 프로그램을 기능 단위로 나눈 것
- 각 모듈은 독립적으로 작성되어, 다른 모듈에 영향을 주지 않고 개발·수정·테스트 가능
- 결합도는 최소화 응집도는 최대화하는 것이 목표

## 2. 추상화 (Abstraction)

- 복잡한 내부 동작은 감추고 중요한 정보만 외부에 제공
- **사용자는 구현을 몰라도 인터페이스만 보고 사용 가능**

| 유형        | 설명                                                                            |
| ----------- | ------------------------------------------------------------------------------- |
| 과정 추상화 | 작업 절차(프로세스)를 하나의 이름으로 묶은 것 (예: 함수)                        |
| 자료 추상화 | 데이터와 그 데이터를 처리하는 연산을 하나의 구조로 묶은 것 (예: 구조체, 클래스) |
| 제어 추상화 | 제어 흐름을 단순화하기 위한 추상화 (예: 반복문, 조건문, 이벤트 처리 등)         |

## 3. 정보 은닉 (Information Hiding)

- 객체 내부의 상태나 구현을 외부에 직접 노출하지 않음
- 접근 제어자 (`private`, `protected`, `public`) 사용
- **다른 모듈이 접근하거나 변경하지 못하도록 하는 기법**

## 4. 협약(Contract)에 의한 설계 (Design by Contract)

- 객체 간의 상호작용에 대해 명확한 규약을 정의
- **선행조건**, **결과조건**, **불변조건** 명시

| 구분     | 설명                                               |
| -------- | -------------------------------------------------- |
| 선행조건 | 오퍼레이션이 호출되기 전에 참이 되어야할 조건      |
| 결과조건 | 오퍼레이션이 수행된 후 만족되어야 할 조건          |
| 불변조건 | 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 |

## 5. 파이프-필터 패턴 (Pipe and Filter)

- 데이터를 일련의 처리 단계(필터)로 구성하여 처리
- 각 필터는 독립적으로 구현되며, 파이프를 통해 데이터 전달
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용

## 6. 모델-뷰-컨트롤러 패턴 (MVC)

- 사용자 인터페이스와 비즈니스 로직 분리
- Model: 서브시스템의 핵심 기능과 데이터를 보관
- View: 사용자에게 정보를 표시
- Controller: 사용자의 입력을 받아 모델에게 명령을 보냄
- 예: 웹 애플리케이션에서 사용자의 요청을 컨트롤러가 받고, 모델을 통해 처리 후 뷰에 결과 출력

## 7. 기타 설계 패턴

| 구분              | 설명                                                            |
| ----------------- | --------------------------------------------------------------- |
| 마스터-슬레이브   | 마스터가 제어를 담당하고, 슬레이브가 명령을 수행하는 구조       |
| 브로커            | 분산된 객체 간의 통신을 중개자(Broker)가 처리하는 구조          |
| 피어 투 피어(P2P) | 모든 노드가 대등한 입장에서 데이터를 주고받는 구조              |
| 이벤트-버스       | 이벤트 생산자와 소비자가 이벤트 버스를 통해 비동기적으로 통신   |
| 블랙보드          | 여러 컴포넌트가 공유 데이터 저장소(블랙보드)를 통해 협력        |
| 인터프리터        | 언어의 문법을 정의하고, 해당 언어로 작성된 명령을 해석하여 실행 |

## 8. 클래스 (Class)

- 객체를 생성하기 위한 틀
- 속성(필드) + 기능(메서드) 포함
- 클래스에 속한 각각의 객체를 **인스턴스(Instance)** 라고 함

## 9. 메시지 (Message)

- 객체의 동작이나 연산을 일으키는 외부의 요구 사항
- 객체 지향에서 동작의 핵심 수단

## 10. 캡슐화 (Encapsulation)

- 데이터와 메서드를 하나의 단위로 묶고, 외부 접근 제한
- 정보 은닉을 가능하게 하며, 무결성과 일관성을 유지
- 인터페이스가 단순해지고 객체 간의 결합도가 낮아짐

## 11. 상속 (Inheritance)

- 상위 클래스의 속성과 기능을 하위 클래스가 물려받음
- 중복 코드 제거, 유지보수 편리
- 단일 상속만 지원(Java 기준)
- 예: `Animal` → `Dog`, `Cat` 상속

## 12. 객체지향 분석

- 사용자의 요구사항을 **객체, 속성, 연산, 관계** 관점에서 분석
- 시스템을 구성하는 객체를 식별하고 관계 및 행위 정의
- 분석 단계에서 추상화, 캡슐화, 상속 등 개념을 적용

## 13. 객체지향 분석 방법론

| 구분                   | 설명                                                       |
| ---------------------- | ---------------------------------------------------------- |
| 럼바우 (Rumbaugh, OMT) | 객체, 동적, 기능 모델로 구성된 대표적인 객체지향 분석 기법 |
| 부치 (Booch)           | 클래스와 객체의 행위 중심, 미시적 설계에 강점              |
| Jacobson               | Use Case(사용 사례) 중심 분석, 요구사항 포착에 용이        |
| Coad와 Yourdon         | 객체-속성-연산-클래스 간 관계를 중심으로 분석              |
| Wirfs-Brock            | 책임 주도 설계 방식, 객체의 역할과 책임을 중시             |

## 14. 럼바우 분석 기법 (OMT, Object Modeling Technique)

- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링

| 모델      | 설명                               |
| --------- | ---------------------------------- |
| 객체 모델 | 클래스, 객체, 속성, 관계           |
| 동적 모델 | 상태도(state diagram), 이벤트 흐름 |
| 기능 모델 | 자료 흐름도(DFD), 함수 흐름 표현   |

## 15. 객체지향 설계 원칙 (SOLID 원칙)

| 원칙                       | 설명                                                               |
| -------------------------- | ------------------------------------------------------------------ |
| SRP (단일 책임 원칙)       | 클래스는 하나의 책임만 가져야 함                                   |
| OCP (개방-폐쇄 원칙)       | 확장에는 열려 있고 변경에는 닫혀야 함                              |
| LSP (리스코프 치환 원칙)   | 자식 클래스는 부모 클래스를 대체할 수 있어야 함                    |
| ISP (인터페이스 분리 원칙) | 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 됨      |
| DIP (의존 역전 원칙)       | 고수준 모듈은 저수준 모듈에 의존하면 안 되며, 추상화에 의존해야 함 |
