# ✅ 4. 서버프로그램 구현(소프트웨어 개발 환경 구축, 형상 관리, 공통 모듈, 테스트 수행 등)

# 개발환경 구축

개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 일

개발 환경은 응용 소프트웨어가 운영될 환경과 유사하게 구축할 것!

## 🧶 개발언어 선정 기준

적합성 / 효율성 / 이식성 / 친밀성 / 범용성

## 🧶 분류

빌드 도구: 작성 코드의 빌드 및 배포를 수행

- Ant / Gradle / Maven

구현 도구: 개발자의 코드 작성 / 디버깅 / 수정 등 지원

- Eclipse / Intellij / Spring Tool Suite 등

테스트 도구: 코드의 기능 검진 및 전체 품질 향상 지원

- xUnit / PMD / Findbugs / Cppcheck 등

형상 관리 도구: 개발자들의 코드와 리소스들의 버전 관리

- CVS / Subvision / Git

## 🧶 서버 하드웨어 개발 환경

### 웹 서버

- HTTP 기반 요청/응답 처리
- 웹 상의 정적 컨텐츠 처리(Css, Javascript, Image)
- 대역폭 제한으로 네트워크 트래픽 포화 방지
- 가상 호스팅으로 1 서버 多 도메인 연결
- 사용자 인증

### 웹 어플리케이션 서버 (WAS)

- 동적 컨텐츠(Servlet, JSP) 처리

### 데이터베이스 서버

- 데이터의 수집, 저장을 위한 용도

### 파일 서버

- 파일 저장 하드웨어
- 물리 저장 장치 활용 서버

## 🧶 클라이언트 하드웨어 개발 환경

### 클라이언트 프로그램

- 설치를 통해 사용자와 커뮤니케이션하는 프로그램

### 웹 브라우저

- 구글, 파이어폭스, 엣지, 사파리, 웨일 등과 같이 웹과 통신하여 웹의 리소스들을 GUI로 표현해주는 일종의 '`프로그램`'

### 모바일 앱/웹

## 🧶 소프트웨어 개발 환경

### 운영체제

- 서버의 하드웨어를 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어
- Windows / Linux / Unix

### 미들웨어

- 컴퓨터와 컴퓨터 간 연결을 쉽고 안전하게 할 수 있또록 해주고 관리를 도와주는 소프트웨어
- Weblogic / Tomcat / Jeus 등

### DBMS

- 데이터베이스를 관리해주는 소프트웨어
- Oracle / Mysql / postgreSql 등

## 🧶 형상 관리의 절차

- 형상 식별: 형상 관리 대상 정의 및 식별(**`git init`**, **`git add`**)
- 형상 통제: 소프트웨어의 변경 요구, 평가, 승인(**`git branch`**, **`git commit`**, **`git push`**, Pull Request, Merge Request)
- 형상 감사: 소프트웨어 베이스라인의 무결성 평가
- 형상 기록: 형상 결과 보고서 작성 (**`git log`**, **`git diff`**)

## 🧶 **소프트웨어 형상 관리 도구 유형**

### 공유 폴더 방식

약속된 위치의 공유 폴더에 복사하는 방식

RCS, SCCS

### 클라이언트 / 서버 방식

중앙에 버전 관리 시스템을 항시 동작시키는 방식

CVS, SVN

### 분산 저장소 방식

로컬 저장소, 원격 저장소에 분리 저장하는 방식

Git

# 공통 모듈 구현

## 🧶 재사용 프로그래밍

### 객체자메

객체 지향

제네릭

자동

메타

## 🧶 재공학과 재개발

### 재공학

- 기존 소프트웨어의 기능 개선 및 새로이 재활용
- **기존 시스템을 최대한 활용**하면서, 품질·생산성·유지보수성을 높이는 것

### 재개발

- 완전히 새로운 소프트웨어 개발 또는 기존 시스템에 새로운 기능 추가
- 기존 시스템이 너무 낡았거나, 요구사항이 크게 바뀌어 **새로운 시스템이 필요할 때** 적용

## 🧶 모듈과 모듈화

### 모듈

하나의 완전한 기능을 수행하는 독립 실체

함수, 메서드, 프로시저 등 하나의 일처리 단위

### 모듈화

기능 단위의 모듈로 분해하는 설계 및 구현 기법

모듈 / 컴포넌트 / 서비스

함수 / 매크로 / 인라인

### 공통 모듈

전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드

클래스 / 라이브러리 / 컴포넌트 / 프레임워크

## 🧶 응집도 ⬆️

모듈의 독립성

얼마나 기능이 잘 응집되어 있는가?

높을수록 좋음

- **우**리 **놀(논)**던 **시절** 먹었던 **통**통한 **순**대 **기**가 막혔지!
    
    낮음 ⇒ 높음 순
    
    - **우연적 응집**: **서로 연관 없는** 기능들이 모여 있음
    - **논리적 응집**: **유사한 성격**의 기능들이 모여 있지만, 실행은 조건에 따라 달라짐.
    - **시간적 응집**: **특정 시점**(초기화, 종료 등)에 함께 실행되는 기능들이 모여 있음.
    - **절차적 응집**: 여러 기능이 **순서대로 실행**되지만, 서로 직접적인 데이터 연관은 없음.
    - **통신적 응집**: **동일한 입력이나 출력**을 사용하는 기능들이 한 모듈에 모여 있음.
    - **순차적 응집**: 한 기능의 **출력이 다음 기능의 입력**이 되어 순서대로 처리됨.
    - **기능적 응집**: 모듈이 **오직 하나의 명확한 목적**(기능)만을 수행함.

## 🧶 결합도 ⬇️

모듈 간의 상호의존성

얼마나 다른 모듈과 연관되어 있는가?

낮을수록 좋음

- (프로젝트에서) **자스** **제외**하고는 **공**은 **내**꺼다?
    
    낮음 ⇒ 높은 순
    
    - **자료 결합**: **필요한 값만 인자로 전달**하며, 가장 바람직함.
    - **스탬프 결합**: 배열, 오브젝트 등 복합 **자료구조**를 인자로 전달함.
    - **제어 결합**: **제어 신호(플래그 등)**를 인자로 전달하여 흐름을 제어함.
    - **외부 결합**: **외부에서 정의된 데이터**를 여러 모듈이 참조함.
    - **공통 결합**: 여러 모듈이 **전역변수**를 함께 사용함.
    - **내용 결합**: 다른 모듈의 **내부 변수나 기능을 직접 사용**함.

## 🧶 MVC

**Model**: 내부 비즈니스 로직을 처리하기 위한 역할

**View**: 모델, 컨트롤러가 보여주려고 하는 것들을 화면에 처리

**Controller**: 모델이 어떻게 처리할지를 알려주는 역할, 뷰에 화면 요청 결과 전달

## 🧶 Fan-in & Fan-out

Fan-in: 어떤 모듈을 호출하는 모듈의 수 (진입 차수)

Fan-out: 어떤 모듈이 호출하는 모듈의 수 (진출 차수)

## 🧶 공통 모듈 테스트

| **화**이트박스 테스트 | - 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식
- 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트를 수행
- N-S 차트 & 논리를 기술 |
| --- | --- |
| **메**서드 기반 테스트 | - 공통 모듈 외부에 공개된 메서드 기반의 테스트
- 메서드에 서로 다른 파라미터 값을 호출하면서 다양한 테스트를 수행 |
| **화**면 기반 테스트 | - 사용자용 화면이 있는 경우,
각각의 화면단위로 단위 모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트를 수행 |
| 테스트 **드**라이버 | - 하위 모듈은 있지만 상위 모듈은 없는 경우 사용하는 기법
- 상향식 |
| 테스트 **스**텁 | - 상위 모듈은 있지만 하위 모듈이 없는 경우 사용하는 기법
- 하향식 |

- jUnit : Java 단위 테스트 프레임워크
- CppUnit : C++로 구현한 단위 테스트 도구
- HttpUnit : 웹사이트 테스트 수행을 위한 단위 테스트 도구

# 서버 프로그램 구현

## 🧶 서버 프로그램 구현 절차

### BE

1. DTO/VO 구현
2. SQL문 구현
3. DAO 구현
4. Service 구현 (보안 처리도 포함)
5. Controller 구현

<aside>
💡

**DAO (Data Access Object)란?**

- 데이터베이스에 추상 인터페이스를 제공하는 객체
- 데이터베이스와 직접 소통하는 객체
- 데이터의 저장 / 조회 / 수정 / 삭제 작업 담당

```java
public class UserDAO {
    public User findById(int id) { /* DB에서 사용자 조회 */ }
    public void save(User user) { /* 사용자 저장 */ }
}
```

</aside>

<aside>
💡

**DTO (Data Transfer Object)란?**

- 계층 또는 시스템 또는 프로세스 사이에서 데이터를 전송하는 객체
- 단순 데이터를 담는 용도 ⇒ getter/setter만 있고 비지니스 로직 포함 ❌
- 통신용 모델링이라고 생각하면 됨!

```java
public class UserDTO {
    private String name;
    private String email;
    // getter, setter
}
```

</aside>

<aside>
💡

**VO (Value Object)란?**

- 값 자체를 표현하는 객체
- 고정 클래스(생성 후 불변)
- 주로 읽기 전용
- 값이 같으면 같은 객체로 간주
- 금액, 주소, 좌표 등 변하지 않는 값의 집합을 표현할 때 사용
</aside>

### FE

1. 화면 구현

## 🧶 서버 프로그램 테스트

구현한 어플리케이션이나 시스템이
1. 사용자 요구사항을 만족 시키는지 확인하기 위해
2. 기능 및 비기능 요소의 결함을 찾아내는 활동

### 소프트웨어 테스트 원칙

1. 자기가 개발한 프로그램 및 소스코드 테스팅 ❌
2. 효율적인 결함 제거 법칙 사용하기
- 낚시의 법칙 ⇒ 낚시꾼들은 어디에서 물고기가 많이 잡히는 지 경험적으로 알고 있는 것처럼 개발자들도 기능/모듈/라이브러리에서 결함이 많이 발견된다는 것을 알아야 함
- 파레토의 법칙 - 소프트웨어 결함의 80%는 소프트웨어 기능 중 20%에 집중되어 있음
1. 완벽한 소프트웨어 테스팅은 불가능함 ⇒ 결함을 줄일수는 있으나 결함이 없다고 증명할수 없음 (쓸 때 없이 집착 ㄴㄴ)
2. 테스트는 계획 단계부터! 안 그럼 나중에 비용이 너무 커짐 ⇒ 요르돈의 법칙(눈덩이 법칙)
3. 살충제 패러독스
    - 살충제에 여러 번 노출된 벌레들은 살충제에 내성이 생겨 더 이상 죽지 않음
    - 마찬가지로 동일한 테스트 케이스로 반복 실행 시, 새로운 결함 발견할 수 없으므로 주기적으로 테스트 케이스 리뉴얼이 필요함!
4. 오류 - 부재의 궤변
    
    사용자 요구 사항 만족을 못하거나 사용성이 낮은 소프트웨어는 오류 발견 후 제거를 하더라도 품질 향상이라고 말할 수 없음
    
    즉, 사용성 >>> 오류 개선
    
5. 정황 의존성
    
    소프트웨어 성격에 맞게 테스트를 실시
    

## 🧶 서버 개발 프레임워크

- Spring : Java를 기반으로 만든 프레임워크
    - 전자정부표준 프레임워크의 기반 기술로 사용
- Node.js : 자바스크립트 기반 프레임워크
    - 비동기 입출력처리와 이벤트 위주의 높은처리 성능
- Django : 파이썬 기반 프레임워크
    - 컴포넌트의 재사용과 플러그인화를 강조
- CodeIgniter : PHP 기반 프레임워크
    - 인터페이스가 간편하고 서버자원 적게사용

## 🧶 API

응용 프로그램에서 사용 가능하도록

운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스

Open API와 Close API로 구분

# 배치 프로그램 구현

사용자와 상호작용 없이

일련의 작업을 정기적으로 반복 수행하는 프로그램

일종의 자동화 된 프로그램

- 대용량 데이터 : 대용량 데이터를 처리
- 자동화 : 심각한 오류 사황 외에는 **사용자 개입 없이 동작**
- 견고함 : 유호하지 않은 데이터의 경우에도 처리, **비정상적인 동작 중단이 발생 X**
- 안정성 : 어떤 문제가 생겼는지, 언제 발생했는지 등 **추적 가능해야 함**
- 성능 : **주어진 시간 내**에 처리를 완료

## 🧶 유형

### 이벤트 배치

특정 조건에 반응

### 온 디맨드 배치

사용자의 요구에 반응

### 정기 배치

정해진 시점에 반응

## 🧶 스케쥴러 종류

- 스프링 배치 (Spring Batch)
    - 스프링 프레임워크 기반
    - **DI, AOP, 서비스 추상화**의 스프링 프레임워크의 **3대 요소를 모두 사용**할 수 있는 대용량 처리를 제공하는 스케줄러
    - log 관리, 추적, transaction 관리, 작업 처리 통계 등 다양 기능 제공
- 쿼리 스케줄러
    - 스프링 프레임워크 기반
    - **실행 작업과 실행 스케줄을 정의하는 트리거를 분리**하여 **유연성을 제공**하는 오픈 소스 기반 라이브러리
- **cron**
    - 리눅스/유닉스 계열 기본 스케줄러 도구

## 🧶 **crontab &** crond

어떠한 작업을 주기적으로 실행시키기 위한 리눅스 명령과 데몬

crontab - 명령

crond - 데몬

cf) 데몬이란?

사용자가 직접 실행하지 않아도 백그라운드에서 계속 동작하며, 특정 작업이나 서비스를 제공하는 프로그램.

[분] [시] [일] [월] [요일] [명령어]

| **기호** | **의미** | **예시** |
| --- | --- | --- |
| * | 모든 값 | * |
| ? | 해당 값 없음 | ? |
| , | 여러 값 지정 | 1,2,3 |
| - | 범위 지정 | 1-5 |
| / | 간격(주기) 지정 | */3 |
- 요일의 경우 일(0) 부터 토(6) ⇒ 또는 SUN ~ SAT로 써도 됨(오래된 버전의 경우 불가)
- 산술 연산 불가 ⇒ 오후 4시라고 16대신 12 + 4로 쓸 수 없음
- 입력 시 매 시기마다 수행
- '/단위'를 입력하면 시기를 단위로 나눈 나머지가 0일때마다 수행
- ex1) **`30 */3 * * * /root/com_1.sh`**
    - 매월 매시 0:30분 부터 3시간마다 명령어 수행
- ex2) 매주 월요일 오전 10시에 /etc/check.sh가 실행되도록하는 cron을 작성하시오.
    
    ```java
    // 분 시 일 월 요일 명령어
    
    0 10 * * 1 /etc/check.sh
    ```
    
- ex3) 일요일부터 화요일까지 오후 4시 30분에 /etc/batch.sh가 실행되도록하는cron을 작성하시오.
    
    ```java
    // 분 시 일 월 요일 명령어
    
    30 16 * * 0-2 /etc/batch.sh
    ```
    
- ex4) 일요일부터 목요일까지 오전 2시 30분, 오후 2시 30분에 /etc/batch.sh가 실행되도록하는cron을 작성하시오.
    
    ```java
    // 분 시 일 월 요일 명령어
    
    30 02,14 * * 0-4 /etc/batch.sh
    또는
    30 02,14 * * SUN-THU /etc/batch.sh
    ```
    
- ex5) 1월부터 12월까지 2개월마다 1일, 오전 1시 10분에 /etc/batch.sh가 실행되도록하는cron을 작성하시오.
    
    ```java
    // 분 시 일 월 요일 명령어
    
    10 1 1 */2 * /etc/batch.sh
    또는
    10 1 1 1-12/2 * /etc/batch.sh
    ```
    

## 🧶 Quartz 표현식 (Spring도 여기에 해당)

cron 표현식과 기본적으로는 같지만 초 단위와 연단위도 추가 (단, 연단위는 생략 가능!)