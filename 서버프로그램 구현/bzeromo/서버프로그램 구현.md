***
# ⚡ 서버 프로그램 구현
***

1. **`모듈화`**
	- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
    - 모듈 간 `결합도`의 최소화와 모듈 내 요소들의 `응집도`를 최대화하는 것이 목표


2. **`추상화`**
	- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것
  - |||
    |:---:|:---:|
    |**과정 추상화**|자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
    |**자료 추상화**|데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
    |**제어 추상화**|이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법
    
3. **`협약에 의한 설계`**
	- 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
  - |||
    |:---:|:---:|
    |**선행 조건**|오퍼레이션이 호출되기 전에 참이 되어야 할 조건
    |**결과 조건**|오퍼레이션이 수행된 후 만족되어야 할 조건
    |**불변 조건**|오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

4. **`파이프-필터 패턴`**
	- 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
    - 데이터 변환, 버퍼링, 동기화 등에 주로 사용되며 대표적인 것이 UNIX의 `Shell`
    
5. **`그 외 패턴`**
	- `레이어 패턴`, `클라이언트-서버 패턴`, `MVC 패턴`
    - `마스터-슬레이브 패턴`: 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행 (장애 허용 시스템)
    - `브로커 패턴`: 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결 (분산 환경 시스템)
    - `피어-투-피어 패턴`: 피어라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴 (파일 공유 네트워크)
    - `이벤트-버스 패턴`: 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 패턴 (알림 서비스)
    - `블랙보드 패턴`: 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴 (음성 인식)
    - `인터프리터 패턴`: 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 (번역기, 인터프리터)
    
6. **`메시지`**
	- 객체들 간의 상호작용에 사용되는 수단
    - 객체의 동작이나 연산을 일으키는 외부의 요구 사항
    
7. **`객체지향 분석의 방법론`**
	- `럼바우 방법`: 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
    - `부치 방법`: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
    - `Jacobson 방법`: 유스케이스를 강조하여 사용
    - `Coad와 Yourdon 방법`: E-R 다이어그램을 사용하여 객체의 행위를 모델링
    - `Wiris-Brock 방법`: 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행
    
8. **`럼바우의 분석 기법`**
	- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
    - `객체 모델링(정보 모델링)` - `동적 모델링` - `기능 모델링`
    
    
9. **`객체지향 설계 원칙(SOLID)`**
	- `단일 책임 원칙(SRP)`: 객체는 단 하나의 책임만 가져야한다
    - `개방-폐쇄 원칙(OCP)`: 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다
    - `리스코프 치환 원칙(LSP)`: 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다
    - `인터페이스 분리 원칙(ISP)`: 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다
    - `의존 역전 원칙(DIP)`: 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다
    
10. **`모듈`**
	- 모듈화를 통해 분리된 시스템의 각 기능
    - 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미
    
11. **`결합도`**
	- 모듈 간에 상호 의존하는 정도
    - 두 모듈 사이의 연관 관계
    - 약할수록 품질이 높음
    - 강한 순서대로 (내공외제스자)
    `내용 결합도` - `공통 결합도` - `외부 결합도` - `제어 결합도` - `스탬프 결합도` - `자료 결합도`
    
12. **`결합도의 종류`**
	- `내용 결합도`: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
    - `공통(공유) 결합도`: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
    - `외부 결합도`: 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
    - `제어 결합도`: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
    - `스탬프(검인) 결합도`: 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
    - `자료 결합도`: 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
    
    > _이거 영문으로 쓰라고 나왔었다고 함. 결합도는 `Coupling`이고 나머진 알고 있으리라 믿는다._

13. **`응집도`**
	- 모듈의 내부 요소들이 서로 관련되어 있는 정도
    - 강할수록 품질이 높음
    - 강한 순서대로 (기순교절시논우)
    `기능적` - `순차적` - `교환적` - `절차적` - `시간적` - `논리적` - `우연적`

    
    > _응집도: `Cohesion`_
    
14. **`응집도의 종류`**
	- `기능적 응집도`: 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
    - `순차적 응집도`: 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그다음 활동의 입력 데이터로 사용할 경우의 응집도
    - `교환(통신)적 응집도`: 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
    - `절차적 응집도`: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
    - `시간적 응집도`: 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
    - `논리적 응집도`: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
    - `우연적 응집도`: 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도
    
15. **`팬인/팬아웃`**
	- `팬인`: 어떤 모듈을 제어하는 모듈의 수
    - `팬아웃`: 어떤 모듈에 의해 제어되는 모듈의 수
    
16. **`N-S 차트`**
	- 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법
    - 화살표를 사용하지 않는다
    
    ![](https://velog.velcdn.com/images/bzeromo/post/ced54d83-caa3-479d-970d-eb08f421edc3/image.png)

	> [예시 출처 ](https://jmbean.tistory.com/entry/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%ED%95%84%EA%B8%B0-NS%EC%B0%A8%ED%8A%B8%EB%9E%80?category=1157522)
    
17. **`단위 모듈`**
	- 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
    
18. **`IPC`**
	- 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
    - 대표 메서드로 `공유 메모리`, `소켓`, `세마포어`, `파이프와 네임드 파이프`, `메시지 큐잉`이 있음
    
19. **`테스트 케이스`**
	- 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서
    - **구성 요소**
  - |||
    |:---:|:---:|
    |**식별자**|항목 식별자, 일련번호
    |**테스트 항목**|테스트 대상(모듈 또는 기능)
    |**입력 명세**|테스트 데이터 또는 테스트 조건
    |**출력 명세**|테스트 케이스 수행 시 예상되는 출력 결과
    |**환경 설정**|필요한 하드웨어나 소프트웨어의 환경
    |**특수 절차 요구**|테스트 케이스 수행 시 특별히 요구되는 절차
    |**의존성 기술**|테스트 케이스 간의 의존성
    
 20. **`재사용`**
 	- 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업
  - |||
    |:---:|:---:|
    |**함수와 객체**|클래스나 메소드 단위의 소스 코드를 재사용
    |**컴포넌트**|컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
    |**애플리케이션**|공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용
    
 21. **`코드의 종류`**
 	- `코드`: 자료의 분류, 조합, 기호, 집계, 추출을 용이하게 하기 위해 사용하는 기호
  - `순차 코드`: 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법
  - `블록 코드`: 코드화 대상 항목 중에서 공통선이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
  - `10진 코드`: 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법
  - `그룹 분류 코드`: 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
  - `연상 코드`: 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
  - `표의 숫자 코드`: 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법 (유효 숫자 코드)
  - `합성 코드`: 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법
    
 22. **`디자인 패턴`**
 	- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
    - GOF의 디자인 패턴은 `생성`, `구조`, `행위`로 구분
    
 23. **`생성 패턴`**
 	- 클래스나 객체의 생성과 참조 과정을 정의하는 패턴
  - |||
    |:---:|:---:|
    |**추상 팩토리(키트)**|구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 · 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴
    |**빌더**|작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성하는 패턴
    |**팩토리 메서드**|객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
    |**프로토타입**|원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
    |**싱글톤**|하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없는 패턴
    
    
 24. **`구조 패턴`**
 	- 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
  - |||
    |:---:|:---:|
    |**어댑터**|호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴|
    |**브리지**|구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
    |**컴포지트**|여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
    |**데코레이터**|객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
    |**퍼싸드(Facade)**|복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
    |**플라이웨이트**|인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
    |**프록시**|복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하는 패턴
    
    
 25. **`행위 패턴`**
 	- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
  - |||
    |:---:|:---:|
    |**책임 연쇄**|요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
    |**커맨드**|요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
    |**인터프리터**|언어에 문법 표현을 정의하는 패턴
    |**반복자**|자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
    |**중재자**|수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
    |**메멘토**|특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
    |**옵저버**|한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
    |**상태**|객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용하는 패턴
    |**전략**|동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
    |**템플릿 메소드**|상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
    |**방문자**|각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
    
26. **`crontab 명령어`**
	- 이미 이전에 학습한 부분이 있다.
    - https://velog.io/@bzeromo/DevOps-Linux-crontab
	- **추가적인 정보**
    
  - |명령어|내용|예시|예시 설명|
    |:---:|:---:|:---:|:---:
    |**시기 우측에 /[단위] 입력**|시기를 단위로 나눈 나머지가 0일 때마다 명령어 수행|30 \*/3 * * * /root/process.sh|매월 매일 0:30부터 3시간 마다 프로세스 실행
    |**[시작 시기] - [종료 시기]**|특정 구간에만 반복하여 명령어 실행|* 18-23 20 \* \* /root/process.sh|매월 20일 18시~23시 사이에 매분마다 프로세스 실행
    |**[시기1],[시기2],[시기3]**|특정 시기에 명령어 실행|30 23 25 4,9,11 * /root/process.sh|4/9/11월의 25일 23시 30분에 프로세스 실행
